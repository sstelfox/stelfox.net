<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ruby on Sam Stelfox</title>
    <link>https://stelfox.net/tags/ruby/</link>
    <description>Recent content in ruby on Sam Stelfox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <managingEditor>sam@stelfox.net (Sam Stelfox)</managingEditor>
    <webMaster>sam@stelfox.net (Sam Stelfox)</webMaster>
    <lastBuildDate>Wed, 23 May 2018 07:53:19 -0600</lastBuildDate><atom:link href="https://stelfox.net/tags/ruby/atom.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Parsing HTTP Responses in Ruby</title>
      <link>https://stelfox.net/blog/2018/05/parsing-http-responses-in-ruby/</link>
      <pubDate>Wed, 23 May 2018 07:53:19 -0600</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2018/05/parsing-http-responses-in-ruby/</guid>
      <description>Normally handling HTTP responses in Ruby is rather straight forward. There is a native library in Ruby that handles HTTP requests which parses the responses into a neat data structure that you can then operate on. What if you want to work on stored HTTP responses outside of a connection though? This was the situation I found myself in and thanks to a series of unusual decisions in the Ruby core library I found myself left out in the cold.</description>
    </item>
    
    <item>
      <title>Sharing Context Between Dependent Rake Tasks</title>
      <link>https://stelfox.net/blog/2016/02/sharing-context-between-dependent-rake-tasks/</link>
      <pubDate>Thu, 18 Feb 2016 15:46:12 -0500</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2016/02/sharing-context-between-dependent-rake-tasks/</guid>
      <description>I use Rakefiles quite a bit like traditional Makefiles, in that I specify immediate dependencies for an individual task and Rake will execute all of them. If a file or directory is the dependency and it exists, the task that creates it will be skipped. A contrived Rakefile example might look like:
file &amp;#39;sample&amp;#39; do |t| puts &amp;#39;Creating sample directory&amp;#39; Dir.mkdir(t.name) end file &amp;#39;sample/population.txt&amp;#39; =&amp;gt; [&amp;#39;sample&amp;#39;] do |t| puts &amp;#39;Creating sample population file.</description>
    </item>
    
    <item>
      <title>Ruby Code Quality Metrics</title>
      <link>https://stelfox.net/blog/2015/04/ruby-code-quality-metrics/</link>
      <pubDate>Wed, 22 Apr 2015 16:47:10 -0400</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2015/04/ruby-code-quality-metrics/</guid>
      <description>I like getting unopinionated feedback on the quality of the code I write. Sometimes I can get this from other developers but they tend to get annoyed being asked after every commit whether they consider it an improvement.
There are a few utilities for Ruby codebases such as flay, flog, and rubocop as well as hosted services such as Code Climate that can help you identify chunks of code that can use some work.</description>
    </item>
    
    <item>
      <title>PG::Error: ERROR: Type &#39;Hstore&#39; Does Not Exist</title>
      <link>https://stelfox.net/blog/2014/05/pg-error-error-type-hstore-does-not-exist/</link>
      <pubDate>Wed, 28 May 2014 18:00:55 -0400</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2014/05/pg-error-error-type-hstore-does-not-exist/</guid>
      <description>I&amp;rsquo;ve been using the PostgreSQL&amp;rsquo;s hstore extension in a Rails application lately and kept encountering the error that is this post&amp;rsquo;s namesake. It would specifically happen when a database had been dropped, recreated and I freshly ran the migrations.
It seems that while Rails 4 supports the HStore datatype, it doesn&amp;rsquo;t enable the extension itself. I&amp;rsquo;ve found two ways too solve this issue in wildly different ways.
First Solution: Enable HStore by Default This is the common solution that is recommended too solve this issue.</description>
    </item>
    
    <item>
      <title>Calculating RSA Key Fingerprints in Ruby</title>
      <link>https://stelfox.net/blog/2014/04/calculating-rsa-key-fingerprints-in-ruby/</link>
      <pubDate>Mon, 21 Apr 2014 18:37:04 -0400</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2014/04/calculating-rsa-key-fingerprints-in-ruby/</guid>
      <description>I regularly find myself working on projects that involve the manipulation and storage of RSA keys. In the past I&amp;rsquo;ve never had to worry about identification or presentation of these keys. Normally I&amp;rsquo;ve only got one too three pairs at most that I&amp;rsquo;m manipulating (server, certificate authority, client).
I&amp;rsquo;ve not found myself working on a project that involves presenting the certificates to users for selection and comparison. The obvious way too do this is take a page out of other developer&amp;rsquo;s books and present the key&amp;rsquo;s fingerprint.</description>
    </item>
    
    <item>
      <title>Finding Ruby Subclasses</title>
      <link>https://stelfox.net/blog/2014/02/finding-ruby-subclasses/</link>
      <pubDate>Thu, 20 Feb 2014 07:48:24 -0500</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2014/02/finding-ruby-subclasses/</guid>
      <description>While working through a problem I found it would be immensely useful to be able to enumerate all of the current subclasses of a particular class. After thinking about this for a while I settled on a good old friend of mine, ObjectSpace.
For those not familiar with the ObjectSpace module, it is a means to inspect and access the items being tracked by Ruby&amp;rsquo;s garbage collector. This means it has a hook into every living object, and more dangerously, every near-death object.</description>
    </item>
    
    <item>
      <title>Creating Crypt Style SHA512 Passwords With Ruby</title>
      <link>https://stelfox.net/blog/2014/02/creating-crypt-style-sha512-passwords-with-ruby/</link>
      <pubDate>Mon, 17 Feb 2014 15:28:27 -0500</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2014/02/creating-crypt-style-sha512-passwords-with-ruby/</guid>
      <description>I needed to generate crypt-style SHA512 passwords in ruby for an /etc/shadow file. After a bunch of Googling and messing around with the OpenSSL library I finally found a very simple built-in way to handle this.
require &amp;#39;securerandom&amp;#39; &amp;#39;password&amp;#39;.crypt(&amp;#39;$6$&amp;#39; + SecureRandom.random_number(36 ** 8).to_s(36)) You&amp;rsquo;ll get a string that looks like:
$6$4dksjo1b$Lt194Dwy7r/7WbM8MezYZysmGcxjaiisgTrTBbHkyBZFXeqQTG0J5hep4wLM/AmYxlGNLRy0OWATLDZCqjwCk. If you don&amp;rsquo;t want to use the SecureRandom module you can replace the random call with simply rand(36 ** 8) though this isn&amp;rsquo;t recommended.</description>
    </item>
    
    <item>
      <title>Running Emails Through Ruby</title>
      <link>https://stelfox.net/blog/2013/12/running-emails-through-ruby/</link>
      <pubDate>Sun, 08 Dec 2013 09:32:05 -0500</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2013/12/running-emails-through-ruby/</guid>
      <description>Following up on my earlier post where I covered how to backup your Gmail account using fetchmail and procmail; I wanted to cover how I was additionally processing received mail through ruby.
This was part of a larger project where I was doing statistical analysis on my email while evaluating various data stores. To get the emails into the various data stores, I used the ruby script to parse, process and store the emails as they came in.</description>
    </item>
    
    <item>
      <title>Ruby&#39;s Option Parser - a More Complete Example</title>
      <link>https://stelfox.net/blog/2012/12/rubys-option-parser-a-more-complete-example/</link>
      <pubDate>Sun, 02 Dec 2012 22:59:00 -0500</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2012/12/rubys-option-parser-a-more-complete-example/</guid>
      <description>Recently while writing a Ruby program I needed to parse some command line options. Helpfully Ruby provides a module named OptionParser to make this easy. I found a few parts of the documentation ambiguous and a few others down right confusing.
The catch I hit was the required field. In my mind the definition of a required argument is something that needs to be passed on the command line to continue.</description>
    </item>
    
    <item>
      <title>Keep Your Gems Updated</title>
      <link>https://stelfox.net/blog/2012/11/keep-your-gems-updated/</link>
      <pubDate>Tue, 27 Nov 2012 14:17:00 -0500</pubDate>
      <author>sam@stelfox.net (Sam Stelfox)</author>
      <guid>https://stelfox.net/blog/2012/11/keep-your-gems-updated/</guid>
      <description>I recently went back through my backups recently and found quite a few old abandoned projects. Looking back on the code I see some things I&amp;rsquo;m impressed with, but the majority of the code I wouldn&amp;rsquo;t write today. That&amp;rsquo;s not to say the code is bad, or doesn&amp;rsquo;t function. It did exactly what I wanted to accomplish at the time, just not necessarily in the most efficient way.
This archive of old code made me start wondering how much old code I&amp;rsquo;m using in the projects that I&amp;rsquo;m currently writing.</description>
    </item>
    
  </channel>
</rss>
