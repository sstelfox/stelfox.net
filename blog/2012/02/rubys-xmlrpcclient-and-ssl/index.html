<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="For the past few days I've been working on a Ruby project that needed to interact with a remote XMLRPC API. This isn't particularly unusual but it was the first time from within a Ruby application. Luckily enough Ruby has a built in XMLRPC client that handles a lot of the messy bits.
The XMLRPC::Client class itself seems fairly simple. There are only a handful of methods, five of which are for opening a new connection in a few different ways, and at least two ways to open each type of connection."><meta name=keywords content="blog,programming,linux,systems,personal,rust,philosophy,development,ruby"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://stelfox.net/blog/2012/02/rubys-xmlrpcclient-and-ssl/><title>Ruby's XMLRPC::Client and SSL :: ./Sam_Stelfox.sh — A simple place for my collected thoughts and notes.
</title><link rel=stylesheet href=/main.949191c1dcc9c4a887997048b240354e47152016d821198f89448496ba42e491.css integrity="sha256-lJGRwdzJxKiHmXBIskA1TkcVIBbYIRmPiUSElrpC5JE="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel="shortcut icon" href=/favicon.ico><meta itemprop=name content="Ruby's XMLRPC::Client and SSL"><meta itemprop=description content="For the past few days I've been working on a Ruby project that needed to interact with a remote XMLRPC API. This isn't particularly unusual but it was the first time from within a Ruby application. Luckily enough Ruby has a built in XMLRPC client that handles a lot of the messy bits.
The XMLRPC::Client class itself seems fairly simple. There are only a handful of methods, five of which are for opening a new connection in a few different ways, and at least two ways to open each type of connection."><meta itemprop=datePublished content="2012-02-14T18:08:51+00:00"><meta itemprop=dateModified content="2012-02-14T18:08:51+00:00"><meta itemprop=wordCount content="768"><meta itemprop=keywords content="Development,Ruby"><meta name=twitter:card content="summary"><meta name=twitter:title content="Ruby's XMLRPC::Client and SSL"><meta name=twitter:description content="For the past few days I've been working on a Ruby project that needed to interact with a remote XMLRPC API. This isn't particularly unusual but it was the first time from within a Ruby application. Luckily enough Ruby has a built in XMLRPC client that handles a lot of the messy bits.
The XMLRPC::Client class itself seems fairly simple. There are only a handful of methods, five of which are for opening a new connection in a few different ways, and at least two ways to open each type of connection."><meta property="article:published_time" content="2012-02-14 18:08:51 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>./Sam_Stelfox.sh</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about/>About</a></li><li><a href=/notes/>Notes</a></li><li><a href=/blog/>Posts</a></li></ul></nav><span class=menu-trigger><svg viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://stelfox.net/blog/2012/02/rubys-xmlrpcclient-and-ssl/>Ruby's XMLRPC::Client and SSL</a></h2><div class=post-content><p>For the past few days I've been working on a Ruby project that needed to interact with a remote XMLRPC API. This isn't particularly unusual but it was the first time from within a Ruby application. Luckily enough Ruby has a built in XMLRPC client that handles a lot of the messy bits.</p><p>The <code>XMLRPC::Client</code> class itself seems fairly simple. There are only a handful of methods, five of which are for opening a new connection in a few different ways, and at least two ways to open each type of connection.</p><p>As a starting point this was a simplified chunk of code that I was using to connect to the remote API:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-0-1><a class=lnlinks href=#hl-0-1> 1</a>
</span><span class=lnt id=hl-0-2><a class=lnlinks href=#hl-0-2> 2</a>
</span><span class=lnt id=hl-0-3><a class=lnlinks href=#hl-0-3> 3</a>
</span><span class=lnt id=hl-0-4><a class=lnlinks href=#hl-0-4> 4</a>
</span><span class=lnt id=hl-0-5><a class=lnlinks href=#hl-0-5> 5</a>
</span><span class=lnt id=hl-0-6><a class=lnlinks href=#hl-0-6> 6</a>
</span><span class=lnt id=hl-0-7><a class=lnlinks href=#hl-0-7> 7</a>
</span><span class=lnt id=hl-0-8><a class=lnlinks href=#hl-0-8> 8</a>
</span><span class=lnt id=hl-0-9><a class=lnlinks href=#hl-0-9> 9</a>
</span><span class=lnt id=hl-0-10><a class=lnlinks href=#hl-0-10>10</a>
</span><span class=lnt id=hl-0-11><a class=lnlinks href=#hl-0-11>11</a>
</span><span class=lnt id=hl-0-12><a class=lnlinks href=#hl-0-12>12</a>
</span><span class=lnt id=hl-0-13><a class=lnlinks href=#hl-0-13>13</a>
</span><span class=lnt id=hl-0-14><a class=lnlinks href=#hl-0-14>14</a>
</span><span class=lnt id=hl-0-15><a class=lnlinks href=#hl-0-15>15</a>
</span><span class=lnt id=hl-0-16><a class=lnlinks href=#hl-0-16>16</a>
</span><span class=lnt id=hl-0-17><a class=lnlinks href=#hl-0-17>17</a>
</span><span class=lnt id=hl-0-18><a class=lnlinks href=#hl-0-18>18</a>
</span><span class=lnt id=hl-0-19><a class=lnlinks href=#hl-0-19>19</a>
</span><span class=lnt id=hl-0-20><a class=lnlinks href=#hl-0-20>20</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>require</span> <span class=s1>&#39;xmlrpc/client&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>APIConnection</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>initialize</span><span class=p>(</span><span class=n>username</span><span class=p>,</span> <span class=n>password</span><span class=p>,</span> <span class=n>host</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Build the arguments for the XMLRPC::Client object</span>
</span></span><span class=line><span class=cl>    <span class=n>conn_args</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=ss>:user</span> <span class=o>=&gt;</span> <span class=n>username</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:password</span> <span class=o>=&gt;</span> <span class=n>password</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:host</span> <span class=o>=&gt;</span> <span class=n>host</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:use_ssl</span> <span class=o>=&gt;</span> <span class=kp>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:path</span> <span class=o>=&gt;</span> <span class=s2>&#34;/api&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=vi>@connection</span> <span class=o>=</span> <span class=no>XMLRPC</span><span class=o>::</span><span class=no>Client</span><span class=o>.</span><span class=n>new_from_hash</span><span class=p>(</span><span class=n>conn_args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>version</span>
</span></span><span class=line><span class=cl>    <span class=vi>@connection</span><span class=o>.</span><span class=n>call</span><span class=p>(</span><span class=s2>&#34;version&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>The problem I ran into was when connecting to a server using HTTPS. I knew that this certificate was good however I continued to get the message:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-1-1><a class=lnlinks href=#hl-1-1>1</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>warning: peer certificate won&#39;t be verified in this SSL session
</span></span></code></pre></td></tr></table></div></div><p>Ruby has taken the approach of by default not including any trusted certificate authorities which I greatly appreciate especially considering that in 2010 and 2011 12 certificate authorities were known to have been hacked including major ones such as VeriSign, and <a href=http://www.symantec.com/connect/blogs/diginotar-ssl-breach-update>DigiNotar</a>. Some of which were <a href=http://nakedsecurity.sophos.com/2011/08/29/falsely-issued-google-ssl-certificate-in-the-wild-for-more-than-5-weeks/>proven</a> to have issued false certificates.</p><p>Since <code>XMLRPC::Client</code> doesn't expose it's SSL trust settings through it's methods I went on a bit of a journey through Google to find an answer. What I found was overly disturbing, a lot of people don't seem to understand what SSL is actually for. The solutions I found from the most egregious to least:</p><ul><li>Disabling OpenSSL certificate checking globally with <code>OpenSSL::SSL::VERIFY_NONE</code></li><li>Overriding the <code>Net::HTTP</code> certificate checking</li><li>Disabling OpenSSL certificate checking locally by extending <code>XMLRPC::Client</code> and over-riding how it was establishing connections</li><li>Using an SSL stripping proxy</li></ul><p>I couldn't find a solution out there that didn't the security conscious voice in my head scream in despair. I asked on <a href=http://stackoverflow.com/questions/9199660/why-is-ruby-unable-to-verify-an-ssl-certificate>StackOverflow</a> for a good solution. When I asked I didn't have a good grasp on how Ruby was handling SSL certificates at all. The thorough answer from <a href=http://stackoverflow.com/a/9238221/95114>emboss</a> didn't quite answer my question but it gave me more than enough to really hunt down what I wanted.</p><p>First stop, I needed the certificates that I'll be using to verify the connection. Every single certificate authority that issues certificates for public websites makes the public portion of their certificates available and this is what we need to verify the connection. To find out which ones you specifically need you can go to the API server's address and look at it's certificate information by clicking on the site's lock icon. Every browser is a little different so you'll have to find this out on your own. With Chrome (and perhaps others) you can download each of the certificates in the chain that you'll need to verify the server's certificate.</p><p>The server I was connecting to was using a <a href=http://www.rapidssl.com/>RapidSSL</a> certificate, who has been verified by <a href=http://www.geotrust.com/>GeoTrust</a>. You want to grab their certificates Base64 encoded in PEM format. Stick them all in a <code>ca.crt</code> file.</p><p>How do we get <code>XMLRPC::Client</code> to actually use that information without hacking it all to pieces? <code>Net::HTTP</code> has a few methods that allow you to set the appropriate connection settings and <code>XMLRPC::Client</code> uses <code>Net::HTTP</code>. If <code>XMLRPC::Client</code> allowed to you specify this directly somehow I would've been a lot happier.</p><p>Here's that code snippet again, this time forcing certificate verification with the "ca.crt" file. This code assumes that the "ca.crt" file lives in the same directory as the connection script:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt id=hl-2-1><a class=lnlinks href=#hl-2-1> 1</a>
</span><span class=lnt id=hl-2-2><a class=lnlinks href=#hl-2-2> 2</a>
</span><span class=lnt id=hl-2-3><a class=lnlinks href=#hl-2-3> 3</a>
</span><span class=lnt id=hl-2-4><a class=lnlinks href=#hl-2-4> 4</a>
</span><span class=lnt id=hl-2-5><a class=lnlinks href=#hl-2-5> 5</a>
</span><span class=lnt id=hl-2-6><a class=lnlinks href=#hl-2-6> 6</a>
</span><span class=lnt id=hl-2-7><a class=lnlinks href=#hl-2-7> 7</a>
</span><span class=lnt id=hl-2-8><a class=lnlinks href=#hl-2-8> 8</a>
</span><span class=lnt id=hl-2-9><a class=lnlinks href=#hl-2-9> 9</a>
</span><span class=lnt id=hl-2-10><a class=lnlinks href=#hl-2-10>10</a>
</span><span class=lnt id=hl-2-11><a class=lnlinks href=#hl-2-11>11</a>
</span><span class=lnt id=hl-2-12><a class=lnlinks href=#hl-2-12>12</a>
</span><span class=lnt id=hl-2-13><a class=lnlinks href=#hl-2-13>13</a>
</span><span class=lnt id=hl-2-14><a class=lnlinks href=#hl-2-14>14</a>
</span><span class=lnt id=hl-2-15><a class=lnlinks href=#hl-2-15>15</a>
</span><span class=lnt id=hl-2-16><a class=lnlinks href=#hl-2-16>16</a>
</span><span class=lnt id=hl-2-17><a class=lnlinks href=#hl-2-17>17</a>
</span><span class=lnt id=hl-2-18><a class=lnlinks href=#hl-2-18>18</a>
</span><span class=lnt id=hl-2-19><a class=lnlinks href=#hl-2-19>19</a>
</span><span class=lnt id=hl-2-20><a class=lnlinks href=#hl-2-20>20</a>
</span><span class=lnt id=hl-2-21><a class=lnlinks href=#hl-2-21>21</a>
</span><span class=lnt id=hl-2-22><a class=lnlinks href=#hl-2-22>22</a>
</span><span class=lnt id=hl-2-23><a class=lnlinks href=#hl-2-23>23</a>
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-ruby data-lang=ruby><span class=line><span class=cl><span class=nb>require</span> <span class=s1>&#39;xmlrpc/client&#39;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>APIConnection</span>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>initialize</span><span class=p>(</span><span class=n>username</span><span class=p>,</span> <span class=n>password</span><span class=p>,</span> <span class=n>host</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1># Build the arguments for the XMLRPC::Client object</span>
</span></span><span class=line><span class=cl>    <span class=n>conn_args</span> <span class=o>=</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>      <span class=ss>:user</span> <span class=o>=&gt;</span> <span class=n>username</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:password</span> <span class=o>=&gt;</span> <span class=n>password</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:host</span> <span class=o>=&gt;</span> <span class=n>host</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:use_ssl</span> <span class=o>=&gt;</span> <span class=kp>true</span><span class=p>,</span>
</span></span><span class=line><span class=cl>      <span class=ss>:path</span> <span class=o>=&gt;</span> <span class=s2>&#34;/api&#34;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=vi>@connection</span> <span class=o>=</span> <span class=no>XMLRPC</span><span class=o>::</span><span class=no>Client</span><span class=o>.</span><span class=n>new_from_hash</span><span class=p>(</span><span class=n>conn_args</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=vi>@connection</span><span class=o>.</span><span class=n>instance_variable_get</span><span class=p>(</span><span class=s2>&#34;@http&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>verify_mode</span> <span class=o>=</span> <span class=no>OpenSSL</span><span class=o>::</span><span class=no>SSL</span><span class=o>::</span><span class=no>VERIFY_PEER</span>
</span></span><span class=line><span class=cl>    <span class=vi>@connection</span><span class=o>.</span><span class=n>instance_variable_get</span><span class=p>(</span><span class=s2>&#34;@http&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>ca_file</span> <span class=o>=</span> <span class=no>File</span><span class=o>.</span><span class=n>join</span><span class=p>(</span><span class=no>File</span><span class=o>.</span><span class=n>dirname</span><span class=p>(</span><span class=bp>__FILE__</span><span class=p>),</span> <span class=s2>&#34;ca.crt&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=k>def</span> <span class=nf>version</span>
</span></span><span class=line><span class=cl>    <span class=vi>@connection</span><span class=o>.</span><span class=n>call</span><span class=p>(</span><span class=s2>&#34;version&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>end</span>
</span></span><span class=line><span class=cl><span class=k>end</span>
</span></span></code></pre></td></tr></table></div></div><p>Those last two lines in the initialize method first dive into the connection we've already setup (but before it's been called), grab the of <code>Net::HTTP</code> and tells it to force peer verification and to use the certificate file we created before. No more warning, and we're actually safe.</p></div></article><hr><div class=post-info><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://stelfox.net/tags/development/>development</a></span>
<span class=tag><a href=https://stelfox.net/tags/ruby/>ruby</a></span></p><p><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"/><line x1="1.05" y1="12" x2="7" y2="12"/><line x1="17.01" y1="12" x2="22.96" y2="12"/></svg><a href=5cc61bddb3608f4b520ea01481747b9e2f886434 target=_blank rel=noopener>5cc61bdd</a> @ 2024-07-15</p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.e89fda0f29b95d33f6f4224dd9e5cf69d84aff3818be2b0d73e731689cc374261b016d17d46f8381962fb4a1577ba3017b1f23509d894f6e66431f988c00889e.js integrity="sha512-6J/aDym5XTP29CJN2eXPadhK/zgYvisNc+cxaJzDdCYbAW0X1G+DgZYvtKFXe6MBex8jUJ2JT25mQx+YjACIng=="></script></body></html>