<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="I regularly find myself working on projects that involve the manipulation and storage of RSA keys. In the past I&amp;rsquo;ve never had to worry about identification or presentation of these keys. Normally I&amp;rsquo;ve only got one too three pairs at most that I&amp;rsquo;m manipulating (server, certificate authority, client).
I&amp;rsquo;ve not found myself working on a project that involves presenting the certificates to users for selection and comparison. The obvious way too do this is take a page out of other developer&amp;rsquo;s books and present the key&amp;rsquo;s fingerprint."><meta name=keywords content=",development,ruby,security"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://stelfox.net/blog/calculating-rsa-key-fingerprints-in-ruby/><title>Calculating RSA Key Fingerprints in Ruby :: Sam Stelfox
</title><link rel=stylesheet href=/main.949191c1dcc9c4a887997048b240354e47152016d821198f89448496ba42e491.css integrity="sha256-lJGRwdzJxKiHmXBIskA1TkcVIBbYIRmPiUSElrpC5JE="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Calculating RSA Key Fingerprints in Ruby"><meta itemprop=description content="I regularly find myself working on projects that involve the manipulation and storage of RSA keys. In the past I&rsquo;ve never had to worry about identification or presentation of these keys. Normally I&rsquo;ve only got one too three pairs at most that I&rsquo;m manipulating (server, certificate authority, client).
I&rsquo;ve not found myself working on a project that involves presenting the certificates to users for selection and comparison. The obvious way too do this is take a page out of other developer&rsquo;s books and present the key&rsquo;s fingerprint."><meta itemprop=datePublished content="2014-04-21T18:37:04-04:00"><meta itemprop=dateModified content="2014-04-21T18:37:04-04:00"><meta itemprop=wordCount content="605"><meta itemprop=keywords content="Development,Ruby,Security"><meta name=twitter:card content="summary"><meta name=twitter:title content="Calculating RSA Key Fingerprints in Ruby"><meta name=twitter:description content="I regularly find myself working on projects that involve the manipulation and storage of RSA keys. In the past I&rsquo;ve never had to worry about identification or presentation of these keys. Normally I&rsquo;ve only got one too three pairs at most that I&rsquo;m manipulating (server, certificate authority, client).
I&rsquo;ve not found myself working on a project that involves presenting the certificates to users for selection and comparison. The obvious way too do this is take a page out of other developer&rsquo;s books and present the key&rsquo;s fingerprint."><meta property="article:published_time" content="2014-04-21 18:37:04 -0400 EDT"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>./Sam_Stelfox.sh</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about/>About</a></li><li><a href=/blog/>Blog Posts</a></li><li><a href=/notes/>Various Notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://stelfox.net/blog/calculating-rsa-key-fingerprints-in-ruby/>Calculating RSA Key Fingerprints in Ruby</a></h2><div class=post-content><p>I regularly find myself working on projects that involve the manipulation and
storage of RSA keys. In the past I&rsquo;ve never had to worry about identification
or presentation of these keys. Normally I&rsquo;ve only got one too three pairs at
most that I&rsquo;m manipulating (server, certificate authority, client).</p><p>I&rsquo;ve not found myself working on a project that involves presenting the
certificates to users for selection and comparison. The obvious way too do this
is take a page out of other developer&rsquo;s books and present the key&rsquo;s
fingerprint.</p><p>For those unfamiliar with key fingerprints, they are a condensed way to compare
differing RSA with a high probability that if the fingerprints match, so do the
keys. These are generally based on a cryptographic digest function such as SHA1
and MD5, and you&rsquo;ll see them most commonly when connecting to a new SSH host
and will look like the following:.</p><pre tabindex=0><code>The authenticity of host &#39;some.fakedomain.tld (127.0.0.1)&#39; can&#39;t be established.
RSA key fingerprint is 0c:6c:dd:32:b5:59:40:1d:ac:05:24:4f:04:bc:e0:f3.
Are you sure you want to continue connecting (yes/no)?
</code></pre><p>The string of 32 hex characters presented there can be compared with another
known value to make sure you&rsquo;re connecting to the correct SSH server and will
always be the same length regardless of the bit-strength of the keys used.
Without the fingerprint, users would have to compare 256 hex characters for a
1024 bit key, which is a very low security key.</p><p>You can calculate the SSH fingerprint for your SSH key or a SSH host key using
the <code>ssh-keygen</code> command like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>ssh-keygen -lf ~/.ssh/id_rsa
</span></span><span style=display:flex><span>ssh-keygen -lf /etc/ssh/ssh_host_key.pub
</span></span></code></pre></div><p>It will work when the path is either a private RSA key or a public key
formatted for SSH authorized key files.</p><p>X509 certificates also use a key fingerprint to help identify a certificate&rsquo;s
signing authority. What I rapidly learned through this investigation was that
they are calculated slightly differently from SSH fingerprints even if they&rsquo;re
in the same format.</p><p>I couldn&rsquo;t find any good Ruby code that calculated either, and the alternatives
were some dense C++. Luckily SSH fingerprints are pretty documented in
<a href=http://www.ietf.org/rfc/rfc4253.txt>RFC4253</a> and <a href=http://www.ietf.org/rfc/rfc4716.txt>RFC4716</a>. Fingerprints on RSA keys for use with OpenSSL
are less clear, and there is a different method for calculating the
fingerprints of certificates.</p><p>Slowly working through the undocumented bits of Ruby&rsquo;s OpenSSL wrapper, the
RFCs and a couple of C++ implementations I finally got a set of working
implementations that calculate the following fingerprints in Ruby:</p><ul><li>MD5 & SHA1 fingerprints for RSA SSH keys</li><li>Fingerprints of RSA keys for use with x509 certificates</li><li>Fingerprints of x509 certificates</li></ul><p>The easiest being a regular x509 certificate:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>require <span style=color:#e6db74>&#39;openssl&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path_to_cert <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;/tmp/sample.crt&#39;</span>
</span></span><span style=display:flex><span>cert <span style=color:#f92672>=</span> <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>X509</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Certificate</span><span style=color:#f92672>.</span>new(<span style=color:#66d9ef>File</span><span style=color:#f92672>.</span>read(path_to_cert))
</span></span><span style=display:flex><span>puts <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Digest</span><span style=color:#f92672>::</span><span style=color:#66d9ef>SHA1</span><span style=color:#f92672>.</span>hexdigest(cert<span style=color:#f92672>.</span>to_der)<span style=color:#f92672>.</span>scan(<span style=color:#e6db74>/../</span>)<span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#39;:&#39;</span>)
</span></span></code></pre></div><p>You can compare the output of the above code with OpenSSL&rsquo;s implementation with
the following command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>openssl x509 -in /tmp/sample.crt -noout -fingerprint
</span></span></code></pre></div><p>Please note that case sensitivity doesn&rsquo;t matter here (OpenSSL will return
upper case hex codes).</p><p>The next one I got working was the SSH fingerprints thanks to the RFCs mentioned
earlier.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>require <span style=color:#e6db74>&#39;openssl&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path_to_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;/tmp/ssh_key&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>key <span style=color:#f92672>=</span> <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>PKey</span><span style=color:#f92672>::</span><span style=color:#66d9ef>RSA</span><span style=color:#f92672>.</span>new(<span style=color:#66d9ef>File</span><span style=color:#f92672>.</span>read(path_to_key))
</span></span><span style=display:flex><span>data_string <span style=color:#f92672>=</span> <span style=color:#f92672>[</span><span style=color:#ae81ff>7</span><span style=color:#f92672>].</span>pack(<span style=color:#e6db74>&#39;N&#39;</span>) <span style=color:#f92672>+</span> <span style=color:#e6db74>&#39;ssh-rsa&#39;</span> <span style=color:#f92672>+</span> key<span style=color:#f92672>.</span>public_key<span style=color:#f92672>.</span>e<span style=color:#f92672>.</span>to_s(<span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> key<span style=color:#f92672>.</span>public_key<span style=color:#f92672>.</span>n<span style=color:#f92672>.</span>to_s(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>puts <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Digest</span><span style=color:#f92672>::</span><span style=color:#66d9ef>MD5</span><span style=color:#f92672>.</span>hexdigest(data_string)<span style=color:#f92672>.</span>scan(<span style=color:#e6db74>/../</span>)<span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#39;:&#39;</span>)
</span></span></code></pre></div><p><em>Please note: The above only works for RSA SSH keys.</em></p><p>Calculating a SHA1 fingerprint for SSH hosts is as simple as replacing the
&lsquo;MD5&rsquo; class with &lsquo;SHA1&rsquo; or any of the other support digest algorithms.</p><p>The last one was the hardest to track down and implement, eventually I found
the answer in <a href=http://www.ietf.org/rfc/rfc3279.txt>RFC3279</a> under section 2.3.1 for the format of the public key
I would need to generate before performing a digest calculation on it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ruby data-lang=ruby><span style=display:flex><span>require <span style=color:#e6db74>&#39;openssl&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>path_to_key <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;/tmp/x509_key.pem&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>key <span style=color:#f92672>=</span> <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>PKey</span><span style=color:#f92672>::</span><span style=color:#66d9ef>RSA</span><span style=color:#f92672>.</span>new(<span style=color:#66d9ef>File</span><span style=color:#f92672>.</span>read(path_to_key))
</span></span><span style=display:flex><span>data_string <span style=color:#f92672>=</span> <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>ASN1</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Sequence</span>(<span style=color:#f92672>[</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>ASN1</span><span style=color:#f92672>::</span>Integer<span style=color:#f92672>.</span>new(key<span style=color:#f92672>.</span>public_key<span style=color:#f92672>.</span>n),
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>ASN1</span><span style=color:#f92672>::</span>Integer<span style=color:#f92672>.</span>new(key<span style=color:#f92672>.</span>public_key<span style=color:#f92672>.</span>e)
</span></span><span style=display:flex><span><span style=color:#f92672>]</span>)
</span></span><span style=display:flex><span>puts <span style=color:#66d9ef>OpenSSL</span><span style=color:#f92672>::</span><span style=color:#66d9ef>Digest</span><span style=color:#f92672>::</span><span style=color:#66d9ef>SHA1</span><span style=color:#f92672>.</span>hexdigest(data_string<span style=color:#f92672>.</span>to_der)<span style=color:#f92672>.</span>scan(<span style=color:#e6db74>/../</span>)<span style=color:#f92672>.</span>join(<span style=color:#e6db74>&#39;:&#39;</span>)
</span></span></code></pre></div></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://stelfox.net/tags/development/>development</a></span>
<span class=tag><a href=https://stelfox.net/tags/ruby/>ruby</a></span>
<span class=tag><a href=https://stelfox.net/tags/security/>security</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.85fad2de4f13fec3bcb3b3cb10430cdb44a7b4a9749b32938241a5c6e77718df7624f1002b880521fdc26e24ec1077fda214bf1cb36ee3045510760d09638cae.js integrity="sha512-hfrS3k8T/sO8s7PLEEMM20SntKl0mzKTgkGlxud3GN92JPEAK4gFIf3CbiTsEHf9ohS/HLNu4wRVEHYNCWOMrg=="></script></body></html>