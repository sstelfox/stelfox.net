<!DOCTYPE html>
<html lang='en'><head>
  <meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta name='description' content='Normally handling HTTP responses in Ruby is rather straight forward. There is a native library in Ruby that handles HTTP requests which parses the responses into a neat data structure that you can then operate on. What if you want to work on stored HTTP responses outside of a connection though? This was the situation I found myself in and thanks to a series of unusual decisions in the Ruby core library I found myself left out in the cold.'>
<meta name='theme-color' content='#ffcd00'>

<meta property='og:title' content='Parsing HTTP Responses in Ruby • Sam Stelfox&#39;s Thoughts &amp; Notes'>
<meta property='og:description' content='Normally handling HTTP responses in Ruby is rather straight forward. There is a native library in Ruby that handles HTTP requests which parses the responses into a neat data structure that you can then operate on. What if you want to work on stored HTTP responses outside of a connection though? This was the situation I found myself in and thanks to a series of unusual decisions in the Ruby core library I found myself left out in the cold.'>
<meta property='og:url' content='https://stelfox.net/blog/2018/05/parsing-http-responses-in-ruby/'>
<meta property='og:site_name' content='Sam Stelfox&#39;s Thoughts &amp; Notes'>
<meta property='og:type' content='article'><meta property='article:section' content='blog'><meta property='article:tag' content='ruby'><meta property='article:tag' content='tips'><meta property='article:published_time' content='2018-05-23T07:53:19-06:00'/><meta property='article:modified_time' content='2018-05-23T07:53:19-06:00'/><meta name='twitter:card' content='summary'>

<meta name="generator" content="Hugo 0.61.0-DEV" />

  <title>Parsing HTTP Responses in Ruby • Sam Stelfox&#39;s Thoughts &amp; Notes</title>
  <link rel='canonical' href='https://stelfox.net/blog/2018/05/parsing-http-responses-in-ruby/'>
  
  
  <link rel='icon' href='/favicon.ico'>
<link rel='stylesheet' href='/assets/css/main.ab98e12b.css'><style>
:root{--color-accent:#ffcd00;}
</style>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-32188490-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

  

</head>
<body class='page type-blog'>

  <div class='site'><a class='screen-reader-text' href='#content'>Skip to Content</a><div class='main'><nav id='main-menu' class='menu main-menu' aria-label='Main Menu'>
  <div class='container'>
    
    <ul><li class='item'>
        <a href='/'>Home</a>
      </li><li class='item'>
        <a href='/about/'>About</a>
      </li><li class='item'>
        <a href='/blog/'>Blog Posts</a>
      </li><li class='item'>
        <a href='/notes/'>Various Notes</a>
      </li></ul>
  </div>
</nav><div class='header-widgets'>
        <div class='container'></div>
      </div>

      <header id='header' class='header site-header'>
        <div class='container sep-after'>
          <div class='header-info'><p class='site-title title'>Sam Stelfox&#39;s Thoughts &amp; Notes</p><p class='desc site-desc'>Thoughts from a software engineer, systems architect and Linux gubernāre.</p>
          </div>
        </div>
      </header>

      <main id='content'>


<article lang='en' class='entry'>
  <header class='header entry-header'>
  <div class='container sep-after'>
    <div class='header-info'>
      <h1 class='title'>Parsing HTTP Responses in Ruby</h1>
      

    </div>
    <div class='entry-meta'>
  <span class='posted-on'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"/>
  <line x1="16" y1="2" x2="16" y2="6"/>
  <line x1="8" y1="2" x2="8" y2="6"/>
  <line x1="3" y1="10" x2="21" y2="10"/>
  
</svg>
<span class='screen-reader-text'>Posted on </span>
  <time class='entry-date' datetime='2018-05-23T07:53:19-06:00'>2018, May 23</time>
</span>

  
  
<span class='reading-time'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <circle cx="12" cy="12" r="10"/>
  <polyline points="12 6 12 12 15 15"/>
  
</svg>
5 mins read
</span>


</div>


  </div>
</header>

  
  

  <div class='container entry-content'>
  <p>Normally handling HTTP responses in Ruby is rather straight forward. There is a
native library in Ruby that handles HTTP requests which parses the responses
into a neat data structure that you can then operate on. What if you want to
work on stored HTTP responses outside of a connection though? This was the
situation I found myself in and thanks to a series of unusual decisions in the
Ruby core library I found myself left out in the cold.</p>
<p>For reference this is in the latest stable Ruby as of this writing (2.5.1).</p>
<p>Let's start with a very small HTTP response stored in a variable for us to test
on:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">raw_http_body <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;&lt;-BODY.rstrip
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">Just</span> the body<span style="color:#f92672">...</span>
<span style="color:#66d9ef">BODY</span>

raw_http_response <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;&lt;-RESP.rstrip
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1</span><span style="color:#f92672"></span><span style="color:#f92672">.</span><span style="color:#ae81ff">1</span> <span style="color:#f92672"></span><span style="color:#ae81ff">200</span> <span style="color:#f92672"></span><span style="color:#66d9ef">Ok</span>\r
<span style="color:#e6db74">Connection</span>: close\r
<span style="color:#66d9ef">Content</span><span style="color:#f92672">-</span><span style="color:#e6db74">Length</span>: <span style="color:#75715e">#{raw_http_body.bytesize}\r</span>
\r
<span style="color:#75715e">#{raw_http_body}</span>
<span style="color:#66d9ef">RESP</span>
</code></pre></div><p>The above is a little bit weird but is a minimum reasonable HTTP response. All
lines are approprietly terminated with both a carriage return (explicit) and
a newline (implicit in how the strings are defined). The <code>Content-Length</code>
header is the exact number of bytes present in the body (thus the two <code>#rstrip</code>
calls). The <code>Date</code> header was omitted due to this line in <a href="https://tools.ietf.org/html/rfc7231#section-7.1.1.2">RFC7231</a></p>
<blockquote>
<p>An origin server MUST NOT send a Date header field if it does not have a
clock capable of providing a reasonable approximation of the current instance
in Coordinated Universal Time.</p>
</blockquote>
<p>&hellip;Which the content of this static site does not have.</p>
<p>With our minimal response out of the way how do we go about parsing it? The
<a href="https://ruby-doc.org/stdlib-2.5.1/libdoc/net/http/rdoc/Net/HTTPResponse.html">Ruby 2.5.1 stdlib documentation</a> doesn't specify how it can be created by
end users which usually means it isn't intended for use by users of the
language directly and digging through the Ruby source, you'll see this is
precisely the case. Which means <em><strong>Ruby does not have a HTTP response parser
available in it's standard library</strong></em>. This is pretty frustrating, but maybe it
can be worked around.</p>
<p>How does the <code>Net::HTTP</code> library make use of it? Even if the methods aren't
listed for public documentation they're still public APIs on the class and
should be able to be used without monkey patching right? The response is setup
in <a href="https://github.com/ruby/ruby/blob/v2_5_1/lib/net/http.rb#L958">the connect method of Net::HTTP</a> and it comes down to a few relevant
lines that can be summarized as:</p>
<ol>
<li>Open a socket to the webserver</li>
<li>Write the formatted request to the socket</li>
<li>Pass the socket to <code>HTTPResponse#read_new</code></li>
</ol>
<p>So we need a socket like object containing our response, which we can do with
<code>StringIO</code> and pass it to the appropriate method. Let's see what happens:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">require <span style="color:#e6db74">&#39;net/http&#39;</span>
require <span style="color:#e6db74">&#39;stringio&#39;</span>

resp_io <span style="color:#f92672">=</span> <span style="color:#66d9ef">StringIO</span><span style="color:#f92672">.</span>new(raw_http_response)
response <span style="color:#f92672">=</span> <span style="color:#66d9ef">Net</span><span style="color:#f92672">::</span><span style="color:#66d9ef">HTTPResponse</span><span style="color:#f92672">.</span>read_new(resp_io)
</code></pre></div><p>We get a raised exception:</p>
<blockquote>
<p>Net::HTTPBadResponse: wrong status line: &ldquo;HTTP/1.1 200 Ok\r\n&rdquo;</p>
</blockquote>
<p>That is definitely a valid status line, so what is going on here? Back to
Ruby's source code&hellip; <code>Net::HTTPResponse#read_new</code> starts off by calling
<code>Net::HTTPResponse#read_status_line</code> which uses this regex for extracting and
checking the validity of the status line:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#e6db74">/</span><span style="color:#e6db74">\</span><span style="color:#e6db74">AHTTP(?:</span><span style="color:#e6db74">\/</span><span style="color:#e6db74">(</span><span style="color:#e6db74">\</span><span style="color:#e6db74">d+</span><span style="color:#e6db74">\</span><span style="color:#e6db74">.</span><span style="color:#e6db74">\</span><span style="color:#e6db74">d+))?</span><span style="color:#e6db74">\</span><span style="color:#e6db74">s+(</span><span style="color:#e6db74">\</span><span style="color:#e6db74">d</span><span style="color:#e6db74">\</span><span style="color:#e6db74">d</span><span style="color:#e6db74">\</span><span style="color:#e6db74">d)(?:</span><span style="color:#e6db74">\</span><span style="color:#e6db74">s+(.*))?</span><span style="color:#e6db74">\</span><span style="color:#e6db74">z</span><span style="color:#e6db74">/in</span>
</code></pre></div><p>I had never seen the <code>/n</code> modifier for Ruby's regular expressions and it seems
to be completely undocumented. This turned out to be a red herring as it simply
sets <code>Regexp::NOENCODING</code> (had to dig into the
<a href="https://github.com/ruby/ruby/blob/3527c05a8f4e189772cdac17f166bd9626c24661/spec/ruby/core/regexp/options_spec.rb">spec/ruby/core/regexp/options_spec.rb</a> file to figure that one out).</p>
<p>So why isn't that regular expression matching? Spoiler: It's the newline (the
carriage return is fine). That is a violation of the HTTP spec, but it is
working normally for Ruby's HTTP requests so what gives? Apparently we have to
go deeper&hellip;</p>
<p>It's getting the header string by calling <code>#readline</code> which on standard <a href="http://ruby-doc.org/core-2.5.1/IO.html#method-i-readline">IO</a>
objects returns the newline (The <code>IO</code> class if the base for <code>StringIO</code>, and
<code>Socket</code> objects in addition to many others). In <a href="https://blog.bigbinary.com/2017/03/07/io-readlines-now-accepts-chomp-flag-as-an-argument.html">Ruby 2.4</a> and later there
is a chomp flag that changes this behavior but it isn't being used in this
case, and it would take the carriage return with it if it was.</p>
<p>So&hellip; We must not be operating on an actual <code>IO</code> subclass&hellip; And sure enough,
<code>Net::HTTP#connect</code> after getting the raw socket wraps it in a
<code>Net::BufferedIO</code> object which is another internal hidden class. You can see
the definition <a href="https://github.com/ruby/ruby/blob/v2_5_1/lib/net/protocol.rb#L81">of it here</a> and here is its <code>#readline</code> method:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby"><span style="color:#66d9ef">def</span> <span style="color:#a6e22e"></span><span style="color:#f92672"></span><span style="color:#a6e22e">readline</span>
  readuntil(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>)<span style="color:#f92672">.</span>chop
<span style="color:#66d9ef">end</span>
</code></pre></div><p>Yep, for some reason this one private internal API has decided to complicate a
Ruby standard API convention and strip off the trailing carriage return and new
line. Wrapping our <code>StringIO</code> object in a <code>BufferedIO</code> object does solve this
problem but there is no reason for these complications&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">resp_io <span style="color:#f92672">=</span> <span style="color:#66d9ef">StringIO</span><span style="color:#f92672">.</span>new(raw_http_response)
buf_io <span style="color:#f92672">=</span> <span style="color:#66d9ef">Net</span><span style="color:#f92672">::</span><span style="color:#66d9ef">BufferedIO</span><span style="color:#f92672">.</span>new(resp_io)
response <span style="color:#f92672">=</span> <span style="color:#66d9ef">Net</span><span style="color:#f92672">::</span><span style="color:#66d9ef">HTTPResponse</span><span style="color:#f92672">.</span>read_new(buf_io)
</code></pre></div><p>Or does it?</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">response<span style="color:#f92672">.</span>body
<span style="color:#75715e"># NoMethodError: undefined method `closed?&#39; for nil:NilClass</span>
</code></pre></div><p>We need to pull one more trick from the <code>Net::HTTP#transport_request</code> to get
the body. The first line actually returns the body, but we want to treat this
like a normal HTTPResponse so we want to make sure the <code>#body</code> method works:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">response<span style="color:#f92672">.</span>reading_body(buf_io, <span style="color:#66d9ef">true</span>) { <span style="color:#66d9ef">yield</span> res <span style="color:#66d9ef">if</span> block_given? }
response<span style="color:#f92672">.</span>body
</code></pre></div><p>There are a couple of differences still from a normal response body. The only
one of particular note to me is that normally the response get it's <code>#uri</code> data
from the request. This isn't available with the response alone but can be set
pretty easily:</p>
<pre><code>require 'uri'
response.uri = URI.parse('http://example.tld')
</code></pre><p>Altogether this is what it looks like:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ruby" data-lang="ruby">require <span style="color:#e6db74">&#39;net/http&#39;</span>
require <span style="color:#e6db74">&#39;stringio&#39;</span>
require <span style="color:#e6db74">&#39;uri&#39;</span>

raw_http_body <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;&lt;-BODY.rstrip
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">Just</span> the body<span style="color:#f92672">...</span>
<span style="color:#66d9ef">BODY</span>

raw_http_response <span style="color:#f92672">=</span> <span style="color:#e6db74">&lt;&lt;-RESP.rstrip
</span><span style="color:#e6db74"></span><span style="color:#66d9ef">HTTP</span><span style="color:#f92672">/</span><span style="color:#ae81ff">1</span><span style="color:#f92672"></span><span style="color:#f92672">.</span><span style="color:#ae81ff">1</span> <span style="color:#f92672"></span><span style="color:#ae81ff">200</span> <span style="color:#f92672"></span><span style="color:#66d9ef">Ok</span>\r
<span style="color:#e6db74">Connection</span>: close\r
<span style="color:#66d9ef">Content</span><span style="color:#f92672">-</span><span style="color:#e6db74">Length</span>: <span style="color:#75715e">#{raw_http_body.bytesize}\r</span>
\r
<span style="color:#75715e">#{raw_http_body}</span>
<span style="color:#66d9ef">RESP</span>

resp_io <span style="color:#f92672">=</span> <span style="color:#66d9ef">StringIO</span><span style="color:#f92672">.</span>new(raw_http_response)
buf_io <span style="color:#f92672">=</span> <span style="color:#66d9ef">Net</span><span style="color:#f92672">::</span><span style="color:#66d9ef">BufferedIO</span><span style="color:#f92672">.</span>new(resp_io)

response <span style="color:#f92672">=</span> <span style="color:#66d9ef">Net</span><span style="color:#f92672">::</span><span style="color:#66d9ef">HTTPResponse</span><span style="color:#f92672">.</span>read_new(buf_io)
response<span style="color:#f92672">.</span>reading_body(buf_io, <span style="color:#66d9ef">true</span>) { <span style="color:#66d9ef">yield</span> res <span style="color:#66d9ef">if</span> block_given? }
response<span style="color:#f92672">.</span>uri <span style="color:#f92672">=</span> <span style="color:#66d9ef">URI</span><span style="color:#f92672">.</span>parse(<span style="color:#e6db74">&#39;http://example.tld&#39;</span>)

<span style="color:#75715e"># You now have a valid Net::HTTPResponse object</span>
</code></pre></div>
</div>

  
<footer class='entry-footer'>
  <div class='container sep-before'><div class='tags'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <path d="M20.59,13.41l-7.17,7.17a2,2,0,0,1-2.83,0L2,12V2H12l8.59,8.59A2,2,0,0,1,20.59,13.41Z"/>
  <line x1="7" y1="7" x2="7" y2="7"/>
  
</svg>
<span class='screen-reader-text'>Tags: </span><a class='tag' href='/tags/ruby/'>ruby</a>, <a class='tag' href='/tags/tips/'>tips</a></div>

  </div>
</footer>


</article>

<nav class='entry-nav'>
  <div class='container'><div class='prev-entry sep-before'>
      <a href='/blog/2018/05/quick-and-silent-gigabit-packet-interception/'>
        <span aria-hidden='true'><svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="20" y1="12" x2="4" y2="12"/>
  <polyline points="10 18 4 12 10 6"/>
  
</svg>
 Previous</span>
        <span class='screen-reader-text'>Previous post: </span>Quick and Silent Gigabit Packet Interception</a>
    </div><div class='next-entry sep-before'>
      <a href='/blog/2018/05/setting-up-edgerouter-poe-on-google-fiber/'>
        <span class='screen-reader-text'>Next post: </span>Setting Up EdgeRouter PoE on Google Fiber<span aria-hidden='true'>Next <svg class='icon' viewbox='0 0 24 24' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' aria-hidden='true'>
  
  <line x1="4" y1="12" x2="20" y2="12"/>
  <polyline points="14 6 20 12 14 18"/>
  
</svg>
</span>
      </a>
    </div></div>
</nav>




      </main>

      <footer id='footer' class='footer'>
        <div class='container sep-before'><div class='copyright'>
  <p> &copy; 2011-2020 Sam Stelfox </p>
</div>

        </div>
      </footer>

    </div>
  </div><script>window.__assets_js_src="/assets/js/"</script>

<script src='/assets/js/main.c3bcf2df.js'></script>

</body>

</html>

