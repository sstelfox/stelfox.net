<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="I&amp;rsquo;ve found several places where I needed to be able to update my kernels but for one reason or another can&amp;rsquo;t update the kernel that gets booted initially. A couple of these situations were:
Running Custom or Updated Kernels on DigitalOcean (this is one of their biggest failings IMHO) Allowing updating of kernels on embedded linux devices that require their kernel flashed into NVRAM. Running an embedded system that used an active/backup partition scheme for updating."><meta name=keywords content="blog,programming,linux,systems,personal,rust,philosophy,linux"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://stelfox.net/blog/2014/05/chain-loading-kernels/><title>Chain Loading Kernels :: Sam Stelfox — A simple place for my collected thoughts and notes.
</title><link rel=stylesheet href=/main.c8c76086c15b9d686ec1778dcf935d2ad37f3bb9c23165d2bd157ba7b18e5aec.css integrity="sha256-yMdghsFbnWhuwXeNz5NdKtN/O7nCMWXSvRV7p7GOWuw="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="Chain Loading Kernels"><meta itemprop=description content="I’ve found several places where I needed to be able to update my kernels but for one reason or another can’t update the kernel that gets booted initially. A couple of these situations were:
Running Custom or Updated Kernels on DigitalOcean (this is one of their biggest failings IMHO) Allowing updating of kernels on embedded linux devices that require their kernel flashed into NVRAM. Running an embedded system that used an active/backup partition scheme for updating."><meta itemprop=datePublished content="2014-05-23T11:39:16-04:00"><meta itemprop=dateModified content="2014-05-23T11:39:16-04:00"><meta itemprop=wordCount content="881"><meta itemprop=keywords content="Linux"><meta name=twitter:card content="summary"><meta name=twitter:title content="Chain Loading Kernels"><meta name=twitter:description content="I’ve found several places where I needed to be able to update my kernels but for one reason or another can’t update the kernel that gets booted initially. A couple of these situations were:
Running Custom or Updated Kernels on DigitalOcean (this is one of their biggest failings IMHO) Allowing updating of kernels on embedded linux devices that require their kernel flashed into NVRAM. Running an embedded system that used an active/backup partition scheme for updating."><meta property="article:published_time" content="2014-05-23 11:39:16 -0400 EDT"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>./Sam_Stelfox.sh</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/blog/>Posts</a></li><li><a href=/notes/>Notes</a></li><li><a href=/about/>About Me</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://stelfox.net/blog/2014/05/chain-loading-kernels/>Chain Loading Kernels</a></h2><div class=post-content><p>I&rsquo;ve found several places where I needed to be able to update my kernels but
for one reason or another can&rsquo;t update the kernel that gets booted initially. A
couple of these situations were:</p><ul><li>Running Custom or Updated Kernels on DigitalOcean (this is one of their
biggest failings IMHO)</li><li>Allowing updating of kernels on embedded linux devices that require their
kernel flashed into NVRAM.</li><li>Running an embedded system that used an active/backup partition scheme for
updating.</li></ul><p>In all cases the process was pretty much the same, though there were some
custom changes to the preliminary init system depending on what I needed to get
done, especially with the last one which I may cover in a different article.</p><p>In all cases these were done on a Red Hat based distribution like CentOS,
Scientific Linux, RHEL, or even Fedora. For those users of Debian based systems
you&rsquo;ll need to adjust the scripts too your system though I can&rsquo;t imagine
anything other than the package names changing.</p><p>This assumes you already have the kernel and initramfs you want to boot
installed on your local filesystem at <code>/boot/vmlinuz-custom</code> and
<code>/boot/initramfs.img</code>.</p><p>A quick background on how this works, when the linux kernel is compiled an init
program is configured to be the first thing triggered, by default and in most
situations this will be the executable <code>/sbin/init</code>. This init process is then
responsible for starting the rest of the daemons and processes that make up the
systems we regularly interact with.</p><p>There are tools that allow you too effectively execute another kernel to run in
place of the kernel that is already running. There are some catches though as
the new kernel won&rsquo;t always re-initialize all devices (since they&rsquo;ve already
been initialized) and that can lead too some weird behaviors with processes
that already have hooks on those devices.</p><p>Too prevent any issues you need to load the new kernel as early in the boot
process as possible. Doing this in the init program is pretty much as early as
you can get and makes for a pretty stable system (I&rsquo;ve yet to experience any
issues with machines running this way).</p><p>There are several different init systems and they all behave a little
differently, as far as I know only systemd supports a means of automatically
executing a different kernel but I am personally not a systemd fan and it would
be too late in the boot process already for me too trust the chain load. You
can reliably chain load kernels regardless of what your normal init system is
though very easily and that&rsquo;s what I&rsquo;m going to cover here.</p><p>You&rsquo;ll need to have the kexec tools installed on your system. This is pretty
straight-forward:</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-ca1d2aa-1><a style=outline:none;text-decoration:none;color:inherit href=#code-ca1d2aa-1>1</a>
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>yum install kexec-tools -y</span></span></code></pre></td></tr></table></div></div><p>Next we&rsquo;re going to shift the standard init process off to the side, someplace
still accessible so we can call it later (this will need to be done as root).</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-283a190-1><a style=outline:none;text-decoration:none;color:inherit href=#code-283a190-1>1</a>
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>mv /sbin/init /sbin/init.original</span></span></code></pre></td></tr></table></div></div><p>Now we need to create our own init script that will handle detecting if it&rsquo;s
the new or old kernel, replacing the kernel if it is indeed an old one, and
starting up the normal init process if it&rsquo;s the new kernel.</p><p>Now there is a very important catch here, whatever process starts up first is
given PID 1 which is very important in kernel land. Whatever process is PID 1
will inherit all zombie processes on the system and will need to handle them.
Since our shell script is the first thing started up it will get PID 1 for both
the old and new kernel and getting the process handling code correct is not a
trivial issue.</p><p>What we really need is to hand over PID 1 to the init process so it can do it&rsquo;s
job normally as if the shell script never existed. There is a native function
to do exactly this in these shell scripts: <code>exec</code>.</p><p>Our simple shell script to do the chain load looks like this:</p><div class=highlight><div style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-1><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-1> 1</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-2><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-2> 2</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-3><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-3> 3</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-4><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-4> 4</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-5><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-5> 5</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-6><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-6> 6</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-7><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-7> 7</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-8><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-8> 8</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-9><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-9> 9</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-10><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-10>10</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-11><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-11>11</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-12><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-12>12</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-13><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-13>13</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#737679" id=code-3d25636-14><a style=outline:none;text-decoration:none;color:inherit href=#code-3d25636-14>14</a>
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e6edf3;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic>#!/bin/bash
</span></span></span><span style=display:flex><span><span style=color:#8b949e;font-weight:700;font-style:italic></span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># Detect if this is the old kernel (not booted with the otherwise meaningless</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># &#39;kexeced&#39; parameter.</span>
</span></span><span style=display:flex><span><span style=color:#ff7b72>if</span> <span style=color:#ff7b72;font-weight:700>[</span> <span style=color:#ff7b72>$(</span>grep -q <span style=color:#a5d6ff>&#39; kexeced$&#39;</span> /proc/cmdline<span style=color:#ff7b72>)</span> <span style=color:#ff7b72;font-weight:700>]</span>; <span style=color:#ff7b72>then</span>
</span></span><span style=display:flex><span>  kexec --load /boot/vmlinuz-custom --initrd<span style=color:#ff7b72;font-weight:700>=</span>/boot/initramfs.img <span style=color:#79c0ff>\
</span></span></span><span style=display:flex><span><span style=color:#79c0ff></span>    --reuse-cmdline --append<span style=color:#ff7b72;font-weight:700>=</span><span style=color:#a5d6ff>&#39; kexeced&#39;</span>
</span></span><span style=display:flex><span>  kexec --exec
</span></span><span style=display:flex><span><span style=color:#ff7b72>fi</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># If we made it this far we&#39;re running on the new kernel, trigger the original</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># init binary with all the options passed too this as well as having it take</span>
</span></span><span style=display:flex><span><span style=color:#8b949e;font-style:italic># over this process&#39;s PID.</span>
</span></span><span style=display:flex><span>exec /sbin/init.original <span style=color:#a5d6ff>&#34;</span><span style=color:#79c0ff>$@</span><span style=color:#a5d6ff>&#34;</span></span></span></code></pre></td></tr></table></div></div><p>After rebooting you should be in your new kernel which you can verify with
<code>uname -a</code> and also by examining the <code>/proc/cmdline</code> file for the existence of
the <code>kexeced</code> flag.</p><p>If you modify the script above, be very careful as any execution error will
cause your system to die and recovery will only be possible by mounting the
filesystem on another linux system and fixing it.</p><p>In a future article I&rsquo;ll cover how to use this trick to build an active /
backup system allowing you to fall back to a known good system when booting
fails which is incredibly useful for embedded devices in the field that need
updates but are not easy to get too or replace when an update bricks the
system.</p></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://stelfox.net/tags/linux/>linux</a></span></p><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-git-commit"><circle cx="12" cy="12" r="4"/><line x1="1.05" y1="12" x2="7" y2="12"/><line x1="17.01" y1="12" x2="22.96" y2="12"/></svg><a href=bd9e1ab3269fdee0856f80854c902432ef10f201 target=_blank rel=noopener>bd9e1ab3</a> @ 2024-07-14</p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.85fad2de4f13fec3bcb3b3cb10430cdb44a7b4a9749b32938241a5c6e77718df7624f1002b880521fdc26e24ec1077fda214bf1cb36ee3045510760d09638cae.js integrity="sha512-hfrS3k8T/sO8s7PLEEMM20SntKl0mzKTgkGlxud3GN92JPEAK4gFIf3CbiTsEHf9ohS/HLNu4wRVEHYNCWOMrg=="></script></body></html>