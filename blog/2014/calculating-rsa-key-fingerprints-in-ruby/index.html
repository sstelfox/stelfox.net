<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1, viewport-fit=cover">

    <title>Sam Stelfox&#x27;s Thoughts &amp; Notes</title>
    <link rel="stylesheet" href="https://stelfox.net/colors-dark.css">

    

    
    
  </head>
  <body>
    <header id="header">
      <h1><a href="https:&#x2F;&#x2F;stelfox.net">Sam Stelfox&#x27;s Thoughts &amp; Notes</a></h1>
      <p>Thought&#x27;s from a software engineer, systems architect, and Linux gubernƒÅre.</p>
    </header>
    <div id="page">
      <div id="sidebar">
        
          
          <nav>
            <ul class="nav">
              
                
                  <li>
                    <a href="&#x2F;"><span>Home</span></a>
                  </li>
                
                  <li>
                    <a href="&#x2F;about&#x2F;"><span>About</span></a>
                  </li>
                
                  <li>
                    <a href="&#x2F;blog&#x2F;"><span>Blog</span></a>
                  </li>
                
                  <li>
                    <a href="&#x2F;projects&#x2F;"><span>Projects</span></a>
                  </li>
                
                  <li>
                    <a href="&#x2F;notes&#x2F;"><span>Various Notes</span></a>
                  </li>
                
              
            </ul>
          </nav>
          
        
      </div>
      <div id="content">
        
<article class="post">
  <h1><a href="https:&#x2F;&#x2F;stelfox.net&#x2F;blog&#x2F;2014&#x2F;calculating-rsa-key-fingerprints-in-ruby&#x2F;">Calculating RSA Key Fingerprints in Ruby</a></h1>

  <div class="post-content"><p>I regularly find myself working on projects that involve the manipulation and
storage of RSA keys. In the past I've never had to worry about identification
or presentation of these keys. Normally I've only got one too three pairs at
most that I'm manipulating (server, certificate authority, client).</p>
<span id="continue-reading"></span>
<p>I've not found myself working on a project that involves presenting the
certificates to users for selection and comparison. The obvious way too do this
is take a page out of other developer's books and present the key's
fingerprint.</p>
<p>For those unfamiliar with key fingerprints, they are a condensed way to compare
differing RSA with a high probability that if the fingerprints match, so do the
keys. These are generally based on a cryptographic digest function such as SHA1
and MD5, and you'll see them most commonly when connecting to a new SSH host
and will look like the following:.</p>
<pre><code>The authenticity of host 'some.fakedomain.tld (127.0.0.1)' can't be established.
RSA key fingerprint is 0c:6c:dd:32:b5:59:40:1d:ac:05:24:4f:04:bc:e0:f3.
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>The string of 32 hex characters presented there can be compared with another
known value to make sure you're connecting to the correct SSH server and will
always be the same length regardless of the bit-strength of the keys used.
Without the fingerprint, users would have to compare 256 hex characters for a
1024 bit key, which is a very low security key.</p>
<p>You can calculate the SSH fingerprint for your SSH key or a SSH host key using
the <code>ssh-keygen</code> command like so:</p>
<pre data-lang="sh" class="language-sh "><code class="language-sh" data-lang="sh">ssh-keygen -lf ~/.ssh/id_rsa
ssh-keygen -lf /etc/ssh/ssh_host_key.pub
</code></pre>
<p>It will work when the path is either a private RSA key or a public key
formatted for SSH authorized key files.</p>
<p>X509 certificates also use a key fingerprint to help identify a certificate's
signing authority. What I rapidly learned through this investigation was that
they are calculated slightly differently from SSH fingerprints even if they're
in the same format.</p>
<p>I couldn't find any good Ruby code that calculated either, and the alternatives
were some dense C++. Luckily SSH fingerprints are pretty documented in
<a href="https://www.ietf.org/rfc/rfc4253.txt">RFC4253</a> and <a href="https://www.ietf.org/rfc/rfc4716.txt">RFC4716</a>. Fingerprints on RSA keys for use with OpenSSL
are less clear, and there is a different method for calculating the
fingerprints of certificates.</p>
<p>Slowly working through the undocumented bits of Ruby's OpenSSL wrapper, the
RFCs and a couple of C++ implementations I finally got a set of working
implementations that calculate the following fingerprints in Ruby:</p>
<ul>
<li>MD5 &amp; SHA1 fingerprints for RSA SSH keys</li>
<li>Fingerprints of RSA keys for use with x509 certificates</li>
<li>Fingerprints of x509 certificates</li>
</ul>
<p>The easiest being a regular x509 certificate:</p>
<pre data-lang="ruby" class="language-ruby "><code class="language-ruby" data-lang="ruby">require 'openssl'

path_to_cert = '/tmp/sample.crt'
cert = OpenSSL::X509::Certificate.new(File.read(path_to_cert))
puts OpenSSL::Digest::SHA1.hexdigest(cert.to_der).scan(/../).join(':')
</code></pre>
<p>You can compare the output of the above code with OpenSSL's implementation with
the following command:</p>
<pre data-lang="sh" class="language-sh "><code class="language-sh" data-lang="sh">openssl x509 -in /tmp/sample.crt -noout -fingerprint
</code></pre>
<p>Please note that case sensitivity doesn't matter here (OpenSSL will return
upper case hex codes).</p>
<p>The next one I got working was the SSH fingerprints thanks to the RFCs mentioned
earlier.</p>
<pre data-lang="ruby" class="language-ruby "><code class="language-ruby" data-lang="ruby">require 'openssl'

path_to_key = '/tmp/ssh_key'

key = OpenSSL::PKey::RSA.new(File.read(path_to_key))
data_string = [7].pack('N') + 'ssh-rsa' + key.public_key.e.to_s(0) + key.public_key.n.to_s(0)
puts OpenSSL::Digest::MD5.hexdigest(data_string).scan(/../).join(':')
</code></pre>
<p><em>Please note: The above only works for RSA SSH keys.</em></p>
<p>Calculating a SHA1 fingerprint for SSH hosts is as simple as replacing the
'MD5' class with 'SHA1' or any of the other support digest algorithms.</p>
<p>The last one was the hardest to track down and implement, eventually I found
the answer in <a href="https://www.ietf.org/rfc/rfc3279.txt">RFC3279</a> under section 2.3.1 for the format of the public key
I would need to generate before performing a digest calculation on it.</p>
<pre data-lang="ruby" class="language-ruby "><code class="language-ruby" data-lang="ruby">require 'openssl'

path_to_key = '/tmp/x509_key.pem'

key = OpenSSL::PKey::RSA.new(File.read(path_to_key))
data_string = OpenSSL::ASN1::Sequence([
  OpenSSL::ASN1::Integer.new(key.public_key.n),
  OpenSSL::ASN1::Integer.new(key.public_key.e)
])
puts OpenSSL::Digest::SHA1.hexdigest(data_string.to_der).scan(/../).join(':')
</code></pre>
</div><p class="meta">Posted on <span class="postdate">2014-04-21</span></p></article>

      </div>
      <footer id="footer">
        <p class="copyright">
          
          &copy; 2011 &ndash; 2021 Sam Stelfox | <a href="https://stelfox.net/licenses/">Site Content Licenses</a>
          
        </p>
      </footer>
    </div>
  </body>
</html>
