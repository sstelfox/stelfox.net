#!/usr/bin/env ruby

require 'json'

# A few helpful tips about the Rules file:
#
# * The string given to #compile and #route are matching patterns for
#   identifiers--not for paths. Therefore, you can’t match on extension.
#
# * The order of rules is important: for each item, only the first matching
#   rule is applied.
#
# * Item identifiers start and end with a slash (e.g. “/about/” for the file
#   “content/about.html”). To select all children, grandchildren, … of an
#   item, use the pattern “/about/*/”; “/about/*” will also select the parent,
#   because “*” matches zero or more characters.

preprocess do
  def create_tag_pages
    # Build up a reverse association between tags and items
    tag_list = items.map { |i| (i[:tags] || []) }.flatten
    tag_counts = Hash.new(0)
    tag_list.each { |t| tag_counts[t] += 1 }
    tag_list.uniq!

    # Create a page item for each of various tags
    tag_list.uniq.each do |t|
      @items << Nanoc::Item.new(
        "<%= render 'tag_page', { tag: @tag, tagged_items: @tagged_items } %>",
        {extension: "erb", type: 'tag_page', title: t.gsub("-", " ").titleize },
        "/tags/#{t.to_url}/"
      )
    end

    # Create a tag index page
    @items << Nanoc::Item.new(
      "<%= render 'tag_index', { tag_list: #{tag_list.inspect} } %>",
      {extension: "erb", type: 'tag_index', title: "Tag List"},
      "/tags/"
    )
  end

  def create_knowledge_base_indexes
    kb_pages = @items.select { |i| i.identifier.to_s.start_with?("/knowledge_base/") }
    kb_pages.map! { |i| i.identifier.split("/")[0...-1].join("/") + "/" }
    kb_pages.uniq!.sort!.reject! { |i| @items[i] }
    kb_pages.each do |k|
      @items << Nanoc::Item.new(
        "<%= render 'kb_index' %>",
        {extension: "erb", type: 'kb_index', title: k.split("/")[-1].titleize},
        k
      )
    end
  end

  def reject_unpublished
    @items.reject! { |i| i[:published] == false }
  end

  create_tag_pages
  create_knowledge_base_indexes

  unless ENV['NANOC_MODE'] == 'auto'
    reject_unpublished
  end
end

# Handle processing of stylesheets
compile "/styles/_includes/*" do
  nil
end

compile "/styles/*" do
  filter :sass, syntax: :scss, style: :compact if item[:extension] == "scss"
  filter :rainpress
end

route "/styles/_includes/*" do
  nil
end

route "/styles/*" do
  # TODO: This only changes when the content of the individual file changes, we
  # need it after it's been processed :(
  "/css/#{item.raw_content.checksum}.css"
end

# Handle processing of javascripts
compile "/javascripts/*" do
  (item[:extension] || "").split('.').reverse_each do |e|
    filter :coffeescript if e == "coffee"
    filter :erb, {trim: "-<>"} if e == "erb"
  end

  # If mangling is enabled each javascript file needs to be self-contained as
  # coffee will not directly create top-level objects (the only thing excluded
  # from mangling)

  if ENV['NANOC_MODE'] == 'auto'
    filter :uglify_js, mangle: false, output: { beautify: true, bracketize: true, semicolons: true }
  else
    filter :uglify_js, compress: true #, mangle: false
  end
end

route "/javascripts/*" do
  "/js/#{item.raw_content.checksum}.js"
end

# Yeah htaccess!
compile "/htaccess/" do
  filter :erb, {trim: "-<>"}
end

route "/htaccess/" do
  "/.htaccess"
end

compile "/sitemap" do
  # Remove items explicitely hidden, binary items and anything with an
  # extension that probably shouldn't be indexed by a search engine.
  items = @items.reject { |i| i.path.nil? || i[:hidden] || i.binary? }
  excluded_extensions = %w{ js css txt xml ttf }
  items.reject! { |i| excluded_extensions.include?(i.path.split('.').last) }

  filter :erb, { locals: { sitemap_items: items }, trim: "-<>" }
end

route "/sitemap" do
  "/sitemap.xml"
end

compile "/atom" do
  filter :erb, {trim: "-<>"}
end

route "/atom" do
  "/atom.xml"
end

compile "/static/*" do
  # Do nothing
end

route "/static/*" do
  item.identifier.chop + "." + item[:extension]
end

# Compile tag specific pages
compile "/tags/*/" do
  tag = item.identifier.match(%r{/tags/(.+)/}).captures.first
  tagged_items = items.select { |i| (i[:tags] || []).include?(tag) }

  filter :erb, { locals: { tag: tag, tagged_items: tagged_items }, trim: "-<>"}
  layout "default"
end

compile "/api/v1/*" do
  item[:extension].split(".").reverse_each do |e|
    filter :erb, {trim: "-<>"} if e == "erb"
  end
end

route "/api/v1/*" do
  item.identifier[0...-1] + "." + item[:extension].split(".").first
end

# Handle remaining items
excluded_extensions = %w{ txt xml ttf }

compile "*" do
  if item.binary?
    # don’t filter binary items
  else
    item[:extension].split(".").reverse_each do |e|
      filter :erb, {trim: "-<>"} if e == "erb"

      if e == "md"
        filter :redcarpet,
          options: {
            autolink: true,
            disable_indented_code_blocks: true,
            fenced_code_blocks: true,
            highlight: true,
            lax_spacing: true,
            no_intra_emphasis: true,
            space_after_headers: true,
            strikethrough: true,
            superscript: true,
            tables: true,
            underline: true
          },
          renderer: HTMLWithCoderay
      end
    end

    if @item[:layout]
      layout @item[:layout]
    else
      layout "default" unless excluded_extensions.include?(item[:extension])
    end
  end
end

route "/blog/*/" do
  time, slug = item[:created_at], item[:title].to_url
  "/blog/#{time.year}/#{sprintf("%02d", time.month)}/#{slug}/index.html"
end

route "*" do
  if item.binary? || excluded_extensions.include?(item[:extension])
    # Write item with identifier /foo/ to /foo.ext
    item.identifier.chop + "." + item[:extension]
  else
    # Write item with identifier /foo/ to /foo/index.html
    item.identifier + "index.html"
  end
end

layout "*", :erb, {trim: "-<>"}

