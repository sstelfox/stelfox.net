<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="sam@stelfox.net Sam Stelfox ">
<meta name="description" content="I followed the TAILS setup guide to get a secure offline environment running to perform this generation task. The steps I took are documented in the tails document.
Initial Key Creation For simplicity I wanted to clear out the GnuPG configuration that starts out in place. Makes things a lot nicer later on.
rm -rf ~/.gnupg/* I pulled in the .gnupg/gpg.conf from my dotfiles by hand.
And begin the key generation process" />
<meta name="keywords" content="blog, programming, linux, systems, personal, gpg, linux, security" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://stelfox.net/notes/gpg-process-notes/" />


    <title>
        
            GPG Process Notes :: Sam Stelfox 
        
    </title>




<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flag-icon-css/3.5.0/css/flag-icon.min.css" integrity="sha512-Cv93isQdFwaKBV+Z4X8kaVBYWHST58Xb/jVOcV9aRsGSArZsgAnFIhMpDoMDcFNoUtday1hdjn0nGp3+KZyyFw==" crossorigin="anonymous" referrerpolicy="no-referrer" />



<link rel="stylesheet" href="/main.2a064c455b0ecbd6b1481b3bf9df2441e95838691022f40a5338c2cb1244f075.css" integrity="sha256-KgZMRVsOy9axSBs7&#43;d8kQelYOGkQIvQKUzjCyxJE8HU=">



    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="GPG Process Notes">
<meta itemprop="description" content="I followed the TAILS setup guide to get a secure offline environment running to perform this generation task. The steps I took are documented in the tails document.
Initial Key Creation For simplicity I wanted to clear out the GnuPG configuration that starts out in place. Makes things a lot nicer later on.
rm -rf ~/.gnupg/* I pulled in the .gnupg/gpg.conf from my dotfiles by hand.
And begin the key generation process"><meta itemprop="datePublished" content="2017-10-09T23:35:34+00:00" />
<meta itemprop="dateModified" content="2017-10-09T23:35:34+00:00" />
<meta itemprop="wordCount" content="3083">
<meta itemprop="keywords" content="gpg,linux,security," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GPG Process Notes"/>
<meta name="twitter:description" content="I followed the TAILS setup guide to get a secure offline environment running to perform this generation task. The steps I took are documented in the tails document.
Initial Key Creation For simplicity I wanted to clear out the GnuPG configuration that starts out in place. Makes things a lot nicer later on.
rm -rf ~/.gnupg/* I pulled in the .gnupg/gpg.conf from my dotfiles by hand.
And begin the key generation process"/>



    <meta property="og:title" content="GPG Process Notes" />
<meta property="og:description" content="I followed the TAILS setup guide to get a secure offline environment running to perform this generation task. The steps I took are documented in the tails document.
Initial Key Creation For simplicity I wanted to clear out the GnuPG configuration that starts out in place. Makes things a lot nicer later on.
rm -rf ~/.gnupg/* I pulled in the .gnupg/gpg.conf from my dotfiles by hand.
And begin the key generation process" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://stelfox.net/notes/gpg-process-notes/" /><meta property="article:section" content="notes" />
<meta property="article:published_time" content="2017-10-09T23:35:34+00:00" />
<meta property="article:modified_time" content="2017-10-09T23:35:34+00:00" />






    <meta property="article:published_time" content="2017-10-09 23:35:34 &#43;0000 UTC" />










    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                ./Sam_Stelfox.sh</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/">Home</a></li><li><a href="/about/">About</a></li><li><a href="/blog/">Blog Posts</a></li><li><a href="/notes/">Various Notes</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://stelfox.net/notes/gpg-process-notes/">GPG Process Notes</a></h2>

            
            
            

            <div class="post-content">
                <p>I followed the TAILS setup guide to get a secure offline environment running to
perform this generation task. The steps I took are documented in the tails
document.</p>
<h2 id="initial-key-creation">Initial Key Creation</h2>
<p>For simplicity I wanted to clear out the GnuPG configuration that starts out in
place. Makes things a lot nicer later on.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>rm -rf ~/.gnupg/*
</span></span></code></pre></div><p>I pulled in the .gnupg/gpg.conf from my dotfiles by hand.</p>
<p>And begin the key generation process</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --expert --gen-key
</span></span></code></pre></div><p>Choose &lsquo;8&rsquo; which is RSA (set your own capabilities). Disable all the
capabilities except for Certify and press &lsquo;q&rsquo; to continue. Use a 4096 bit key.
Set the expiration to 2 years. The certificate can be resigned and republished
with a later expiration date.</p>
<p>Set the personal attributes appropriately, a passphrase and let the key
generation happen. Once done, sub-keys need to be generated. We need to edit
the existing key to create more keys.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --expert --edit-key &lt;email used in key&gt;
</span></span></code></pre></div><p>Add any additional email addresses you might need to the key.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg&gt; adduid
</span></span><span style="display:flex;"><span>gpg&gt; uid 1
</span></span><span style="display:flex;"><span>gpg&gt; primary
</span></span></code></pre></div><p>Generate the sub keys:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg&gt; addkey
</span></span></code></pre></div><p>The above will require the master key&rsquo;s private key. Create another &lsquo;8&rsquo; type
key with only the &lsquo;Sign&rsquo; capability and 2048 bits valid for 6 months Do this
again for the encryption and authentication keys. A higher bit usage may be
useful, some smartcards only support 2048, if higher bits are supported 3072 or
4096 may be better.</p>
<p>I cropped and scale an image of myself down to 120x144 (Quality at 50% still
accurately reflected my likeness quite well and came in at 2.8Kb). The image
has to be under 4Kb but the smaller the better. I ended by ensuring the file
was stripped of metadata and minimized as much as I could with <code>jpegoptim -s</code>.
It has to be transferred to the secure TAILS environment and then added to the
certificate while in the editkey mode we&rsquo;re currently in at this point in the
tutorial.</p>
<p>Turns out the size can be up to 240x288&hellip;</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg&gt; addphoto
</span></span></code></pre></div><p>And follow the prompts. When everything is good save the changes made:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg&gt; save
</span></span></code></pre></div><p>Now I need to setup a backup for all the contents in case they&rsquo;re lost or
displaced. We need to backup the keyrings, a raw copy of the master private
key, a revocation certificate just in case, then the public key.  Backup and
export ~/.gnupg/secring.gpg and ~/.gnupg/pubring.gpg</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>mkdir ~/gpg_backups
</span></span><span style="display:flex;"><span>cp ~/.gnupg/{sec,pub}ring.gpg ~/gpg_backups/
</span></span><span style="display:flex;"><span>gpg -a --export-secret-key sstelfox@bedroomprogrammers.net &gt; ~/gpg_backups/secret_key.gpg
</span></span><span style="display:flex;"><span>gpg -a --export sstelfox@bedroomprogrammers.net &gt; ~/gpg_backups/publickey.gpg
</span></span><span style="display:flex;"><span>gpg -a --gen-revoke sstelfox@bedroomprogrammers.net &gt; ~/gpg_backups/revocation_cert.gpg
</span></span></code></pre></div><p>For the revocation key choose &lsquo;Key has been compromised&rsquo; and an empty
description, as that is the intended usage for this particular CRL.</p>
<p>We also want a <code>paperkey</code> backup file of the private key.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --export-secret-key sstelfox@bedroomprogrammers.net | paperkey &gt; ~/gpg_backups/paperkey.bak
</span></span></code></pre></div><p>It is expected that the paperkey.bak file is printed out on a piece of
acid-free paper and put someplace very very safe. In the worst possible
scenario, this needs to be hand typed back into a text file. Once done
restoration can be done by pulling in your public key and the typed file like
the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>paperkey --pubring ~/gpg_backups/publickey.gpg \
</span></span><span style="display:flex;"><span>  --secrets ~/gpg_backups/paperkey.bak --output ~/recovered_secret.gpg
</span></span></code></pre></div><p>We need to then export just the subkeys for day to day usage. This is a
non-obvious practice.</p>
<p>Take out the subkeys:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg -a --export-secret-subkeys sstelfox@bedroomprogrammers.net \
</span></span><span style="display:flex;"><span>  &gt; ~/gpg_backups/subkey_secrets.gpg
</span></span></code></pre></div><p>Delete the secret keys:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --delete-secret-keys sstelfox@bedroomprogrammers.net
</span></span></code></pre></div><p>You&rsquo;ll need to double confirm the deletion. We now have all the public keys we
want and no secret keys&hellip; We need to now import back in just the subkeys.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --import ~/gpg_backups/subkey_secrets.gpg
</span></span></code></pre></div><p>You should see just the subkeys in the the secret ring:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg -K
</span></span></code></pre></div><p>We can then export just the &rsquo;laptop&rsquo; keys.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg -a --export-secret-keys sstelfox@bedroomprogrammers.net &gt; ~/gpg_backup/laptop_keys_secret.gpg
</span></span><span style="display:flex;"><span>gpg -a --export sstelfox@bedroomprogrammers.net &gt; ~/gpg_backup/laptop_keys_public.gpg
</span></span></code></pre></div><p>These two files need are what will be transferred to the laptop and other
machines that they are needed. To import the two files:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --import laptop_keys_public.gpg
</span></span><span style="display:flex;"><span>gpg --import laptop_keys_secret.gpg
</span></span></code></pre></div><p>Laptop keyrings aren&rsquo;t needed with the smartcard assuming the public key
portions are published at the URL set on the smartcard.</p>
<h2 id="normal-smartcards">Normal Smartcards</h2>
<p>The secret keys are best suited to be stored on a smartcard (such as a YubiKey,
though that needs extra configuration). This assumes that pcscd and libccid are
installed on the system being used. TAILS is already setup for it.</p>
<p>The recommended reader &amp; tokens for this kind of use are OpenPGP Smartcard V2
(with breakout) combined with a Gemalto USB Shell Token V2.</p>
<p>By default these keys have a user &amp; admin key set respectively to 123456 and
12345678. If the user pin is mistyped 3 times the card is blocked until the
admin pin is provided. If the admin pin is provided incorrectly three times the
card will be destroyed. We need to change these from the default like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --card-edit
</span></span><span style="display:flex;"><span>&gt; admin
</span></span><span style="display:flex;"><span>&gt; passwd
</span></span></code></pre></div><p>Change the pin then the admin pin (option 1, then 3 respectively). While in we
should set the url metadata field to provide the location where your public key
can be downloaded. In my case <code>https://stelfox.net/publickey.gpg</code> this can be
set using the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>&gt; url
</span></span></code></pre></div><p>Also a few other bits of metadata:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>&gt; name
</span></span><span style="display:flex;"><span>&gt; lang
</span></span></code></pre></div><p>One thing that may be worth considering is the &lsquo;Signature PIN&rsquo; value being set
to &rsquo;not forced&rsquo;. As far as I can tell this is only used to tell the gpg-agent
whether it&rsquo;s allowed to cache the PIN for performing signatures or not.</p>
<p>It will reduce the security of your card if a PIN isn&rsquo;t required for every
signature performed but it make it quite a bit easier to use as part of a
normal workflow. Hostiles won&rsquo;t be able to get the key material but they will
be able to sign data on your behalf that will be very difficult to prove didn&rsquo;t
come from you.</p>
<p>The recommendation is to always force the requirement of a PIN. I believe with
a five minute timeout the risk is acceptable and can make lots of fast changes
inside a git repository managable. The pin will be required again regardless of
time if the card is removed and readded.</p>
<p>NOTE: There seems to be a better option. Using the <code>yubikey-manager</code> package in
Fedora (present in at least Fedora 29) we can enforce the requirement of
touching the pad whenever one of the keys is used. Enter pin once for the
timeout windows then touch for every action. This has the benefit of being a
much easier workflow while preventing an attacker from using the key without a
physical presence. This can be done with the following commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>ykman openpgp touch sig on
</span></span><span style="display:flex;"><span>ykman openpgp touch aut on
</span></span><span style="display:flex;"><span>ykman openpgp touch enc on
</span></span></code></pre></div><p>The above requires having a YubiKey 4 or later.</p>
<p>Exit out and open up the gpg &ndash;edit-key view again. We need to add the subkeys.
First we need to switch to the private key view:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>&gt; toggle
</span></span></code></pre></div><p>For the three keys (numbered 1-3) you want to transfer them using the following
commands:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>&gt; key 1
</span></span><span style="display:flex;"><span>&gt; keytocard
</span></span><span style="display:flex;"><span>&gt; key 1
</span></span></code></pre></div><p>This selects the keys individually, copies them, then deselects them. It needs
to be done for each of them. End this with a &lsquo;save&rsquo; command and you should be
left with just stubs of the keys in the secret keyring.</p>
<p>On new machines that need to have the stubs added we can perform the following
status:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --card-edit
</span></span><span style="display:flex;"><span>&gt; fetch
</span></span><span style="display:flex;"><span>&gt; quit
</span></span></code></pre></div><p>You should be able to view the stubs and their presence on the card with:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg -K
</span></span><span style="display:flex;"><span>gpg --card-status
</span></span></code></pre></div><p>Should be able to test that the card is working by encrypting a message and
then decrypting it with smartcard.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>cat &lt;&lt; EOF &gt; message.txt
</span></span><span style="display:flex;"><span>Just a secret test message...
</span></span><span style="display:flex;"><span>EOF
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gpg -esar sstelfox@bedroomprogrammers.net message.txt
</span></span></code></pre></div><p>It should ask you for your pin before continuing. Decrypting can be done using
the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg -d message.txt.asc
</span></span></code></pre></div><p>That confirms that the signing key &amp; encryption key are both working. The
authentication key is for using the GPG agent as an SSH agent. To test this one
we need to run the gpg-agent with it&rsquo;s SSH compatibility layer like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg-agent --enable-ssh-support
</span></span><span style="display:flex;"><span>source ~/.gpg-agent-info
</span></span></code></pre></div><p>Test to make sure a card is showing up:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>ssh-add -l
</span></span></code></pre></div><p>To get it in an appropriate format for authorized_keys file:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>ssh-add -L
</span></span></code></pre></div><p>For use on other linux systems the scdaemon binary is required which may be in
a different package&hellip;</p>
<ul>
<li>Additional notes: <a href="https://wiki.fsfe.org/TechDocs/CardHowtos/CardWithSubkeysUsingBackups">https://wiki.fsfe.org/TechDocs/CardHowtos/CardWithSubkeysUsingBackups</a></li>
</ul>
<p>We need to check the GPG configuration (gpg.conf) against that link as we may
need to sign and encrypt with an additional alternate key (hidden-encrypt-to
and default-recipient entries).</p>
<p>On gentoo I needed to change the default use flags for app-crypt/gnupg with the
following:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># /etc/portage/package.use/gnupg
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>app-crypt/gnupg smartcard usb
</span></span></code></pre></div><h2 id="final-tasks">Final Tasks</h2>
<p>Get the key ID of the primary key from <code>gpg -k</code> and push it to the common
public key server:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --send-keys 0xBEBEF280BCE92620
</span></span></code></pre></div><p>Also export the file for uploading to my website:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --armor --export 0xBEBEF280BCE92620 &gt; publickey.gpg
</span></span></code></pre></div><p>The only time the master key should be required to come out to play:</p>
<ul>
<li>You need your main key (e.g. to sign another PGP key)</li>
<li>You have to replace your card and want to reuse the subkeys</li>
<li>Revoking subkeys that have been compromised</li>
<li>Your card was lost or stolen and you need to revoke the subkeys</li>
</ul>
<p>TAILS should be booted backup, if a new key needs to get signed it needs to be
imported from a file. Then signed with <code>gpg --sign-key &lt;Key ID&gt;</code>.</p>
<h2 id="key-signing-party">Key Signing Party</h2>
<p>Get a fingerprint summary file and print out copies for people present using
the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --fingerprint sstelfox@bedroomprogrammers.net &gt; key_for_partying.txt
</span></span></code></pre></div><p>Pull keys by their IDs (0x12345678 for the example), compare the contents of
the key to what you expect, sign the key, push it to the keyserver, and email
the owner a copy of their signature.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --recv-keys 0x12345678
</span></span><span style="display:flex;"><span>gpg --list-keys 0x12345678
</span></span><span style="display:flex;"><span>gpg --sign-key 0x12345678
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gpg --send-keys --keyserver keyserver.ubuntu.com 0x12345678
</span></span><span style="display:flex;"><span>gpg --send-keys --keyserver hkps.pool.sks-keyservers.net 0x12345678
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gpg --armor --export 0x12345678 --output 0x12345678.signed-by.your-id.asc
</span></span></code></pre></div><p>Email the 0x12345678.signed-by.your-id.asc file to one of the emails listed in
the key. When someone sends you a signature just import it like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --import your-id.signed-by.0x12345678.asc
</span></span></code></pre></div><p>You can see your signatures with:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --list-sigs &lt;your-id&gt;
</span></span></code></pre></div><p>More note URLs:</p>
<ul>
<li><a href="https://help.ubuntu.com/community/GnuPrivacyGuardHowto">https://help.ubuntu.com/community/GnuPrivacyGuardHowto</a></li>
</ul>
<h2 id="git-notes">Git Notes</h2>
<p>Git needs to be configured with which key to use for signatures. First you need
to find your key ID, this can be done using the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --list-secret-keys
</span></span></code></pre></div><p>The key ID will look something like: <code>8EE30EAB</code>. Configure the global signing
key using the following command, replacing the sample key ID with yours:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>git config --global user.signingkey 8EE30EAB
</span></span></code></pre></div><p>Ensure that they are doing this automatically:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>git config --global commit.gpgsign true
</span></span></code></pre></div><p>This will ask you for your pin or password on your GPG key everytime you commit
which can be remedied by using a GPG agent. This will reduce your security
generally though.</p>
<h2 id="key-transitions">Key Transitions</h2>
<p>For key transitions where your key hasn&rsquo;t been compromised, a transition
statement needs to be published by both the old and new key. I have a <a href="/note_files/gnupg/key_transition_template.txt">sample
transition statement</a> that can be filled in with your respective
information. Variables in message are embedded with {var} commands are {{cmd}}.</p>
<p>The variables in the template are firstName, fullName, email, oldKeyId,
newKeyId, pubKeyUrl, and pubStmntUrl. The pubKeyUrl and pubStmntUrl variables
should be valid paths to files on an HTTPS protected webserver.</p>
<p>Once you&rsquo;ve filled out the transition statement you need to ensure both keys
are cross signed and the signatures are published.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --local-user $oldKeyId --sign-key $newKeyId
</span></span><span style="display:flex;"><span>gpg --local-user $newKeyId --sign-key $oldKeyId
</span></span><span style="display:flex;"><span>gpg --send-keys $oldKeyId $newKeyId
</span></span></code></pre></div><p>The file itself still needs to be signed by both keys which can be done with
the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --local-user $oldKeyId --local-user $newKeyId --clearsign $keyTransitionFile
</span></span></code></pre></div><p>If both keys don&rsquo;t exist on the same machine you&rsquo;ll need to refer to the
section titled &lsquo;Multiple Clearsigned Signatures&rsquo; for how to handle the
situation.</p>
<p>I recommend you publish the key transition with a name that includes the date,
like <code>key-transition-2017-08-17.txt</code>.</p>
<h2 id="expiration--renewal-of-subkeys">Expiration / Renewal of Subkeys</h2>
<p>TODO: I need to cover certificate key transitions and signed key transition
statements.</p>
<h3 id="option-1-generate-a-new-signing--encryption-key">Option 1: Generate a new signing / encryption key</h3>
<p>Pros:</p>
<ul>
<li>Most secure</li>
<li>Some level of forward secrecy (over large time scales)</li>
<li>Helps protect against unknown key compromises</li>
</ul>
<p>Cons:</p>
<ul>
<li>Only one keypair stored per smartcard (decrypting old files means restoring a
backup of the old key)</li>
<li>More complicated</li>
<li>Requires users to refresh their keys about you</li>
</ul>
<p>Steps:</p>
<ol>
<li>Generate new keys</li>
<li>Generate CRLs for old keys</li>
<li>Load keys on to smartcard</li>
<li>Push new keys and CRLs to keyservers</li>
</ol>
<h3 id="option-2-extend-expiration">Option 2: Extend Expiration</h3>
<p>Pros:</p>
<ul>
<li>Simple</li>
<li>Fast</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg --edit-key 0x12345678
</span></span><span style="display:flex;"><span>gpg&gt; key 1
</span></span><span style="display:flex;"><span>gpg&gt; expire
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>gpg&gt; key 1
</span></span><span style="display:flex;"><span>gpg&gt; key 2
</span></span><span style="display:flex;"><span>gpg&gt; expire
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>gpg&gt; save
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>gpg --send-keys 0x12345678
</span></span></code></pre></div><h2 id="maintenance">Maintenance</h2>
<p>To ensure we get updated keys and revocation announcements the keys in your
keyring should be periodically refreshed with the public key server. This can
be done all at once using the following command:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg2 --refresh-keys
</span></span></code></pre></div><p>Likewise after modifying your own key it should be pushed to the public key
servers for consumption and availability of others.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>PRIMARY_KEY_EMAIL=sstelfox@bedroomprogrammers.net
</span></span><span style="display:flex;"><span>gpg2 --send-key $(gpg2 -k $PRIMARY_EMAIL | grep pub | awk &#39;{ print $2 }&#39; | cut -d &#39;/&#39; -f 2)
</span></span></code></pre></div><p>There is a social network disclosure that occurs when all keys are refreshed at
once. The description of this disclosure is:</p>
<blockquote>
<p>We assume there probably exists at least one subset of public keys in this
keyring that identifies it, i.e. no other individual&rsquo;s keyring contain the
same subset of public keys.</p>
</blockquote>
<p>A personal thought potentially making this attack easier, it is very likely
that one of the keys being refreshed is owner of the keyring itself.</p>
<p>Trusted SSL communications (hkps) eliminates this threat for passive snoopers,
the analysis could still be done on the keyserver itself.</p>
<p>To avoid this individual keys would have to be refreshed independently over
time. The requests could still be tied to the keyring machine&rsquo;s IP address to
correlate all the refreshed keys to build back up the contents of the keyring.
Avoiding this would require use of individual Tor circuits to mask and
distribute key refreshes.</p>
<p>A project has been built up to handle this issue. The following are relevant:</p>
<ul>
<li><a href="https://code.openhub.net/file?fid=BbMaEKchr9cDAOVs8ozX5mJ40g8&amp;cid=RfbvTf3fwdw&amp;fp=405976&amp;mp&amp;projSelected=true#L0">https://code.openhub.net/file?fid=BbMaEKchr9cDAOVs8ozX5mJ40g8&amp;cid=RfbvTf3fwdw&amp;fp=405976&amp;mp&amp;projSelected=true#L0</a></li>
<li><a href="https://github.com/EtiennePerot/parcimonie.sh/blob/master/parcimonie.sh">https://github.com/EtiennePerot/parcimonie.sh/blob/master/parcimonie.sh</a></li>
</ul>
<h2 id="diagnostics">Diagnostics</h2>
<h3 id="no-usuable-subkey">No Usuable Subkey</h3>
<p>One one of my devices I was persistently getting an odd error message whenever
I tried to sign something. The error message was:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ gpg2 -esar sam@stelfox.net sample-file
</span></span><span style="display:flex;"><span>gpg: no default secret key: Unusable secret key
</span></span><span style="display:flex;"><span>gpg: tor-setup-script.sh: sign+encrypt failed: Unusable secret key
</span></span></code></pre></div><p>Turns out I hadn&rsquo;t updated my public keys on that device and <code>gpg2 --card-edit</code>
followed by a <code>fetch</code> didn&rsquo;t actually update my certificate. I needed to
refresh the key from the key server to get my new signatures and public key and
retrust it.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg2 --refresh-keys 0x30856D4EA0FFBA8F
</span></span><span style="display:flex;"><span>gpg2 --edit-key 0x30856D4EA0FFBA8F
</span></span><span style="display:flex;"><span>trust
</span></span></code></pre></div><h3 id="card-not-visible-to-user-may-be-seen-by-root">Card Not Visible to User (May be seen by root)</h3>
<p>I installed <code>pcsc-tools</code> to get <code>pcsc_scan</code> but I don&rsquo;t believe that
contributed to the fix. Ultimately I needed to start up the <code>pcscd</code> service and
replug my yubikey.</p>
<h3 id="unable-to-connect-to-dirmngr-ipc-connect-call-failed">Unable to connect to dirmngr (IPC connect call failed)</h3>
<p>While trying to refresh keys I was getting the following error:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg: connecting dirmngr at &#39;/run/user/1000/gnupg/S.dirmngr&#39; failed: IPC connect call failed
</span></span></code></pre></div><p>I rebooted the machine, and that didn&rsquo;t solve it. Ultimately I believe it was
permissions / ownership issues on the <code>~/.gnupg/crls.d</code> directory but I can&rsquo;t
be entirely sure.</p>
<p>I solved this issue by deleting everything in my <code>.gnupg</code> directory and
checking out the version from my dotfiles again.</p>
<h2 id="remote-usage-of-smartcard">Remote Usage of Smartcard</h2>
<p>Basically relies on the extra-socket option for gpg-agent. May be able to
accomplish this with something like the following command (path may be
incorrect):</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>ssh -R /run/user/1000/gnupg/S.gpg-agent:/home/sstelfox/.gnupg/S.gpg-agent.remote  -o &#34;StreamLocalBindUnlink=yes&#34; remote-host
</span></span></code></pre></div><p>This could also live in an <code>ssh/config</code> parameter like so:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Host remote
</span></span><span style="display:flex;"><span>  RemoteForward /run/user/1000/gnupg/S.gpg-agent:/home/sstelfox/.gnupg/S.gpg-agent.remote
</span></span><span style="display:flex;"><span>  StreamLocalBindUnlink yes
</span></span></code></pre></div><p>The following command should work but will warn about the agent being in
restricted mode.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg-connect-agent /bye
</span></span></code></pre></div><h2 id="multiple-clearsigned-signatures">Multiple Clearsigned Signatures</h2>
<p>If multiple keys on different machines need to perform a clearsign on a
document the normal method doesn&rsquo;t support combining these signatures to be
verified in one pass. This is valuable for allowing multiple independent people
to attest to the validity of a document and make it easy for people to validate
the correctness of it.</p>
<h3 id="notes">Notes</h3>
<p>If the private keys are on the same machine the <code>--local-user</code> flag can simply
be specified multiple times. This is likely the most applicable for
key-transition statements.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg2 --local-user pers1 --local-user pers2 --clearsign content
</span></span></code></pre></div><p>ONLY PARTIALLY IDEAL: Detached signatures can be combined in the same way and
don&rsquo;t require a lot of the sed magic used here. A detached signature can be
generated with:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg2 --armor --detach-sign content
</span></span></code></pre></div><p>If this is done only the dearmor, split, combine, enarmor steps need to be
performed.</p>
<h3 id="process">Process</h3>
<p>First we need content to sign:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>echo &#39;A very important statement about a very important topic.&#39; &gt; content
</span></span></code></pre></div><p>Each signatory should receive or generate a copy of the content and verify it.
This transport is beyond the scope of this document but could easily be done
with a standard <code>gpg2 -esa -r pers1 -r pers2 content</code> and emailed then
decrypted.</p>
<p>Once each user has a copy and verified it. They need to perform a normal
clearsign on the content and send the signed message back to an individual to
perform the combinatory process.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg2 --clearsign content
</span></span></code></pre></div><p>This assumes you now have the signed contents file from pers1 and pers2 in the
files <code>content.pers1.asc</code> and <code>content.pers2.asc</code>. Verify both signatures are
valid:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg2 --verify content.pers1.asc
</span></span><span style="display:flex;"><span>gpg2 --verify content.pers2.asc
</span></span></code></pre></div><p>We need to verify the content is still identical in both files (one of them
could have changed the content before signing to be tricky). This is kind of a
formality since the signature won&rsquo;t check out for at least one of them if the
content differs between the two in any way.</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sed -n &#39;1,/SIGNATURE/ p&#39; content.pers1.asc | sha1sum
</span></span><span style="display:flex;"><span>sed -n &#39;1,/SIGNATURE/ p&#39; content.pers2.asc | sha1sum
</span></span></code></pre></div><p>We then need to extract just the signature blocks from each message and turn
them into the raw gpg2 packets:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>sed -n &#39;/SIGNATURE/,$ p&#39; content.pers1.asc | gpg2 --dearmor | gpgsplit --no-split &gt; pers1.sig
</span></span><span style="display:flex;"><span>sed -n &#39;/SIGNATURE/,$ p&#39; content.pers2.asc | gpg2 --dearmor | gpgsplit --no-split &gt; pers2.sig
</span></span></code></pre></div><p>We then combine them into one enarmored signature (order doesn&rsquo;t matter):</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>cat pers1.sig pers2.sig | gpg2 --enarmor | sed -n &#39;5,$ p&#39; | grep -v -- ----- &gt; combo.sig
</span></span></code></pre></div><p>And append the signatures back onto the content:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(sed -n &#39;1,/SIGNATURE/ p&#39; content.pers1.asc; echo; cat combo.sig; \
</span></span><span style="display:flex;"><span>  echo &#39;-----END PGP SIGNATURE-----&#39;) &gt; content.combo.asc
</span></span></code></pre></div><p>Verify the signatures are still good:</p>
<div class="highlight"><pre tabindex="0" style="color:#c9d1d9;background-color:#0d1117;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>gpg2 --verify content.combo.asc
</span></span></code></pre></div>
            </div>
        </article>

        <hr />

        <div class="post-info">
            
    <p>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7" y2="7"></line></svg>

        <span class="tag"><a href="https://stelfox.net/tags/gpg/">gpg</a></span>
        <span class="tag"><a href="https://stelfox.net/tags/linux/">linux</a></span>
        <span class="tag"><a href="https://stelfox.net/tags/security/">security</a></span>
        
    </p>

            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.c90b8161416b87c69a8e02683b54ddd6edb90aea699648bf655e6cbc45b419b8e465d196e715772463dba35a6faf5decb2eb247480d38680484d54645b434570.js" integrity="sha512-yQuBYUFrh8aajgJoO1Td1u25Cupplki/ZV5svEW0GbjkZdGW5xV3JGPbo1pvr13ssuskdIDThoBITVRkW0NFcA=="></script>



    </body>
</html>
