<!doctype html><html lang=en><head><meta charset=UTF-8><meta http-equiv=X-UA-Compatible content="ie=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=author content><meta name=description content="I followed the TAILS setup guide to get a secure offline environment running to perform this generation task. The steps I took are documented in the tails document.
Initial Key Creation For simplicity I wanted to clear out the GnuPG configuration that starts out in place. Makes things a lot nicer later on.
rm -rf ~/.gnupg/* I pulled in the .gnupg/gpg.conf from my dotfiles by hand.
And begin the key generation process"><meta name=keywords content=",gpg,linux,security"><meta name=robots content="noodp"><meta name=theme-color content><link rel=canonical href=https://stelfox.net/notes/gnupg/><title>GPG Process Notes :: Sam Stelfox
</title><link rel=stylesheet href=/main.949191c1dcc9c4a887997048b240354e47152016d821198f89448496ba42e491.css integrity="sha256-lJGRwdzJxKiHmXBIskA1TkcVIBbYIRmPiUSElrpC5JE="><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/safari-pinned-tab.svg color><link rel="shortcut icon" href=/favicon.ico><meta name=msapplication-TileColor content><meta itemprop=name content="GPG Process Notes"><meta itemprop=description content="I followed the TAILS setup guide to get a secure offline environment running to perform this generation task. The steps I took are documented in the tails document.
Initial Key Creation For simplicity I wanted to clear out the GnuPG configuration that starts out in place. Makes things a lot nicer later on.
rm -rf ~/.gnupg/* I pulled in the .gnupg/gpg.conf from my dotfiles by hand.
And begin the key generation process"><meta itemprop=datePublished content="2017-10-09T23:35:34+00:00"><meta itemprop=dateModified content="2017-10-09T23:35:34+00:00"><meta itemprop=wordCount content="3083"><meta itemprop=keywords content="Gpg,Linux,Security"><meta name=twitter:card content="summary"><meta name=twitter:title content="GPG Process Notes"><meta name=twitter:description content="I followed the TAILS setup guide to get a secure offline environment running to perform this generation task. The steps I took are documented in the tails document.
Initial Key Creation For simplicity I wanted to clear out the GnuPG configuration that starts out in place. Makes things a lot nicer later on.
rm -rf ~/.gnupg/* I pulled in the .gnupg/gpg.conf from my dotfiles by hand.
And begin the key generation process"><meta property="article:published_time" content="2017-10-09 23:35:34 +0000 UTC"></head><body><div class=container><header class=header><span class=header__inner><a href=/ style=text-decoration:none><div class=logo><span class=logo__mark>></span>
<span class=logo__text>./Sam_Stelfox.sh</span>
<span class=logo__cursor></span></div></a><span class=header__right><nav class=menu><ul class=menu__inner><li><a href=/about/>About</a></li><li><a href=/blog/>Blog Posts</a></li><li><a href=/notes/>Various Notes</a></li></ul></nav><span class=menu-trigger><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M0 0h24v24H0z" fill="none"/><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/></svg></span></span></span></header><div class=content><main class=post><div class=post-info></p></div><article><h2 class=post-title><a href=https://stelfox.net/notes/gnupg/>GPG Process Notes</a></h2><div class=post-content><p>I followed the TAILS setup guide to get a secure offline environment running to
perform this generation task. The steps I took are documented in the tails
document.</p><h2 id=initial-key-creation>Initial Key Creation</h2><p>For simplicity I wanted to clear out the GnuPG configuration that starts out in
place. Makes things a lot nicer later on.</p><pre tabindex=0><code>rm -rf ~/.gnupg/*
</code></pre><p>I pulled in the .gnupg/gpg.conf from my dotfiles by hand.</p><p>And begin the key generation process</p><pre tabindex=0><code>gpg --expert --gen-key
</code></pre><p>Choose &lsquo;8&rsquo; which is RSA (set your own capabilities). Disable all the
capabilities except for Certify and press &lsquo;q&rsquo; to continue. Use a 4096 bit key.
Set the expiration to 2 years. The certificate can be resigned and republished
with a later expiration date.</p><p>Set the personal attributes appropriately, a passphrase and let the key
generation happen. Once done, sub-keys need to be generated. We need to edit
the existing key to create more keys.</p><pre tabindex=0><code>gpg --expert --edit-key &lt;email used in key&gt;
</code></pre><p>Add any additional email addresses you might need to the key.</p><pre tabindex=0><code>gpg&gt; adduid
gpg&gt; uid 1
gpg&gt; primary
</code></pre><p>Generate the sub keys:</p><pre tabindex=0><code>gpg&gt; addkey
</code></pre><p>The above will require the master key&rsquo;s private key. Create another &lsquo;8&rsquo; type
key with only the &lsquo;Sign&rsquo; capability and 2048 bits valid for 6 months Do this
again for the encryption and authentication keys. A higher bit usage may be
useful, some smartcards only support 2048, if higher bits are supported 3072 or
4096 may be better.</p><p>I cropped and scale an image of myself down to 120x144 (Quality at 50% still
accurately reflected my likeness quite well and came in at 2.8Kb). The image
has to be under 4Kb but the smaller the better. I ended by ensuring the file
was stripped of metadata and minimized as much as I could with <code>jpegoptim -s</code>.
It has to be transferred to the secure TAILS environment and then added to the
certificate while in the editkey mode we&rsquo;re currently in at this point in the
tutorial.</p><p>Turns out the size can be up to 240x288&mldr;</p><pre tabindex=0><code>gpg&gt; addphoto
</code></pre><p>And follow the prompts. When everything is good save the changes made:</p><pre tabindex=0><code>gpg&gt; save
</code></pre><p>Now I need to setup a backup for all the contents in case they&rsquo;re lost or
displaced. We need to backup the keyrings, a raw copy of the master private
key, a revocation certificate just in case, then the public key. Backup and
export ~/.gnupg/secring.gpg and ~/.gnupg/pubring.gpg</p><pre tabindex=0><code>mkdir ~/gpg_backups
cp ~/.gnupg/{sec,pub}ring.gpg ~/gpg_backups/
gpg -a --export-secret-key sstelfox@bedroomprogrammers.net &gt; ~/gpg_backups/secret_key.gpg
gpg -a --export sstelfox@bedroomprogrammers.net &gt; ~/gpg_backups/publickey.gpg
gpg -a --gen-revoke sstelfox@bedroomprogrammers.net &gt; ~/gpg_backups/revocation_cert.gpg
</code></pre><p>For the revocation key choose &lsquo;Key has been compromised&rsquo; and an empty
description, as that is the intended usage for this particular CRL.</p><p>We also want a <code>paperkey</code> backup file of the private key.</p><pre tabindex=0><code>gpg --export-secret-key sstelfox@bedroomprogrammers.net | paperkey &gt; ~/gpg_backups/paperkey.bak
</code></pre><p>It is expected that the paperkey.bak file is printed out on a piece of
acid-free paper and put someplace very very safe. In the worst possible
scenario, this needs to be hand typed back into a text file. Once done
restoration can be done by pulling in your public key and the typed file like
the following:</p><pre tabindex=0><code>paperkey --pubring ~/gpg_backups/publickey.gpg \
  --secrets ~/gpg_backups/paperkey.bak --output ~/recovered_secret.gpg
</code></pre><p>We need to then export just the subkeys for day to day usage. This is a
non-obvious practice.</p><p>Take out the subkeys:</p><pre tabindex=0><code>gpg -a --export-secret-subkeys sstelfox@bedroomprogrammers.net \
  &gt; ~/gpg_backups/subkey_secrets.gpg
</code></pre><p>Delete the secret keys:</p><pre tabindex=0><code>gpg --delete-secret-keys sstelfox@bedroomprogrammers.net
</code></pre><p>You&rsquo;ll need to double confirm the deletion. We now have all the public keys we
want and no secret keys&mldr; We need to now import back in just the subkeys.</p><pre tabindex=0><code>gpg --import ~/gpg_backups/subkey_secrets.gpg
</code></pre><p>You should see just the subkeys in the the secret ring:</p><pre tabindex=0><code>gpg -K
</code></pre><p>We can then export just the &rsquo;laptop&rsquo; keys.</p><pre tabindex=0><code>gpg -a --export-secret-keys sstelfox@bedroomprogrammers.net &gt; ~/gpg_backup/laptop_keys_secret.gpg
gpg -a --export sstelfox@bedroomprogrammers.net &gt; ~/gpg_backup/laptop_keys_public.gpg
</code></pre><p>These two files need are what will be transferred to the laptop and other
machines that they are needed. To import the two files:</p><pre tabindex=0><code>gpg --import laptop_keys_public.gpg
gpg --import laptop_keys_secret.gpg
</code></pre><p>Laptop keyrings aren&rsquo;t needed with the smartcard assuming the public key
portions are published at the URL set on the smartcard.</p><h2 id=normal-smartcards>Normal Smartcards</h2><p>The secret keys are best suited to be stored on a smartcard (such as a YubiKey,
though that needs extra configuration). This assumes that pcscd and libccid are
installed on the system being used. TAILS is already setup for it.</p><p>The recommended reader & tokens for this kind of use are OpenPGP Smartcard V2
(with breakout) combined with a Gemalto USB Shell Token V2.</p><p>By default these keys have a user & admin key set respectively to 123456 and
12345678. If the user pin is mistyped 3 times the card is blocked until the
admin pin is provided. If the admin pin is provided incorrectly three times the
card will be destroyed. We need to change these from the default like so:</p><pre tabindex=0><code>gpg --card-edit
&gt; admin
&gt; passwd
</code></pre><p>Change the pin then the admin pin (option 1, then 3 respectively). While in we
should set the url metadata field to provide the location where your public key
can be downloaded. In my case <code>https://stelfox.net/publickey.gpg</code> this can be
set using the following command:</p><pre tabindex=0><code>&gt; url
</code></pre><p>Also a few other bits of metadata:</p><pre tabindex=0><code>&gt; name
&gt; lang
</code></pre><p>One thing that may be worth considering is the &lsquo;Signature PIN&rsquo; value being set
to &rsquo;not forced&rsquo;. As far as I can tell this is only used to tell the gpg-agent
whether it&rsquo;s allowed to cache the PIN for performing signatures or not.</p><p>It will reduce the security of your card if a PIN isn&rsquo;t required for every
signature performed but it make it quite a bit easier to use as part of a
normal workflow. Hostiles won&rsquo;t be able to get the key material but they will
be able to sign data on your behalf that will be very difficult to prove didn&rsquo;t
come from you.</p><p>The recommendation is to always force the requirement of a PIN. I believe with
a five minute timeout the risk is acceptable and can make lots of fast changes
inside a git repository managable. The pin will be required again regardless of
time if the card is removed and readded.</p><p>NOTE: There seems to be a better option. Using the <code>yubikey-manager</code> package in
Fedora (present in at least Fedora 29) we can enforce the requirement of
touching the pad whenever one of the keys is used. Enter pin once for the
timeout windows then touch for every action. This has the benefit of being a
much easier workflow while preventing an attacker from using the key without a
physical presence. This can be done with the following commands:</p><pre tabindex=0><code>ykman openpgp touch sig on
ykman openpgp touch aut on
ykman openpgp touch enc on
</code></pre><p>The above requires having a YubiKey 4 or later.</p><p>Exit out and open up the gpg &ndash;edit-key view again. We need to add the subkeys.
First we need to switch to the private key view:</p><pre tabindex=0><code>&gt; toggle
</code></pre><p>For the three keys (numbered 1-3) you want to transfer them using the following
commands:</p><pre tabindex=0><code>&gt; key 1
&gt; keytocard
&gt; key 1
</code></pre><p>This selects the keys individually, copies them, then deselects them. It needs
to be done for each of them. End this with a &lsquo;save&rsquo; command and you should be
left with just stubs of the keys in the secret keyring.</p><p>On new machines that need to have the stubs added we can perform the following
status:</p><pre tabindex=0><code>gpg --card-edit
&gt; fetch
&gt; quit
</code></pre><p>You should be able to view the stubs and their presence on the card with:</p><pre tabindex=0><code>gpg -K
gpg --card-status
</code></pre><p>Should be able to test that the card is working by encrypting a message and
then decrypting it with smartcard.</p><pre tabindex=0><code>cat &lt;&lt; EOF &gt; message.txt
Just a secret test message...
EOF

gpg -esar sstelfox@bedroomprogrammers.net message.txt
</code></pre><p>It should ask you for your pin before continuing. Decrypting can be done using
the following:</p><pre tabindex=0><code>gpg -d message.txt.asc
</code></pre><p>That confirms that the signing key & encryption key are both working. The
authentication key is for using the GPG agent as an SSH agent. To test this one
we need to run the gpg-agent with it&rsquo;s SSH compatibility layer like so:</p><pre tabindex=0><code>gpg-agent --enable-ssh-support
source ~/.gpg-agent-info
</code></pre><p>Test to make sure a card is showing up:</p><pre tabindex=0><code>ssh-add -l
</code></pre><p>To get it in an appropriate format for authorized_keys file:</p><pre tabindex=0><code>ssh-add -L
</code></pre><p>For use on other linux systems the scdaemon binary is required which may be in
a different package&mldr;</p><ul><li>Additional notes: <a href=https://wiki.fsfe.org/TechDocs/CardHowtos/CardWithSubkeysUsingBackups>https://wiki.fsfe.org/TechDocs/CardHowtos/CardWithSubkeysUsingBackups</a></li></ul><p>We need to check the GPG configuration (gpg.conf) against that link as we may
need to sign and encrypt with an additional alternate key (hidden-encrypt-to
and default-recipient entries).</p><p>On gentoo I needed to change the default use flags for app-crypt/gnupg with the
following:</p><pre tabindex=0><code># /etc/portage/package.use/gnupg

app-crypt/gnupg smartcard usb
</code></pre><h2 id=final-tasks>Final Tasks</h2><p>Get the key ID of the primary key from <code>gpg -k</code> and push it to the common
public key server:</p><pre tabindex=0><code>gpg --send-keys 0xBEBEF280BCE92620
</code></pre><p>Also export the file for uploading to my website:</p><pre tabindex=0><code>gpg --armor --export 0xBEBEF280BCE92620 &gt; publickey.gpg
</code></pre><p>The only time the master key should be required to come out to play:</p><ul><li>You need your main key (e.g. to sign another PGP key)</li><li>You have to replace your card and want to reuse the subkeys</li><li>Revoking subkeys that have been compromised</li><li>Your card was lost or stolen and you need to revoke the subkeys</li></ul><p>TAILS should be booted backup, if a new key needs to get signed it needs to be
imported from a file. Then signed with <code>gpg --sign-key &lt;Key ID></code>.</p><h2 id=key-signing-party>Key Signing Party</h2><p>Get a fingerprint summary file and print out copies for people present using
the following command:</p><pre tabindex=0><code>gpg --fingerprint sstelfox@bedroomprogrammers.net &gt; key_for_partying.txt
</code></pre><p>Pull keys by their IDs (0x12345678 for the example), compare the contents of
the key to what you expect, sign the key, push it to the keyserver, and email
the owner a copy of their signature.</p><pre tabindex=0><code>gpg --recv-keys 0x12345678
gpg --list-keys 0x12345678
gpg --sign-key 0x12345678

gpg --send-keys --keyserver keyserver.ubuntu.com 0x12345678
gpg --send-keys --keyserver hkps.pool.sks-keyservers.net 0x12345678

gpg --armor --export 0x12345678 --output 0x12345678.signed-by.your-id.asc
</code></pre><p>Email the 0x12345678.signed-by.your-id.asc file to one of the emails listed in
the key. When someone sends you a signature just import it like so:</p><pre tabindex=0><code>gpg --import your-id.signed-by.0x12345678.asc
</code></pre><p>You can see your signatures with:</p><pre tabindex=0><code>gpg --list-sigs &lt;your-id&gt;
</code></pre><p>More note URLs:</p><ul><li><a href=https://help.ubuntu.com/community/GnuPrivacyGuardHowto>https://help.ubuntu.com/community/GnuPrivacyGuardHowto</a></li></ul><h2 id=git-notes>Git Notes</h2><p>Git needs to be configured with which key to use for signatures. First you need
to find your key ID, this can be done using the following command:</p><pre tabindex=0><code>gpg --list-secret-keys
</code></pre><p>The key ID will look something like: <code>8EE30EAB</code>. Configure the global signing
key using the following command, replacing the sample key ID with yours:</p><pre tabindex=0><code>git config --global user.signingkey 8EE30EAB
</code></pre><p>Ensure that they are doing this automatically:</p><pre tabindex=0><code>git config --global commit.gpgsign true
</code></pre><p>This will ask you for your pin or password on your GPG key everytime you commit
which can be remedied by using a GPG agent. This will reduce your security
generally though.</p><h2 id=key-transitions>Key Transitions</h2><p>For key transitions where your key hasn&rsquo;t been compromised, a transition
statement needs to be published by both the old and new key. I have a <a href=/note_files/gnupg/key_transition_template.txt>sample
transition statement</a> that can be filled in with your respective
information. Variables in message are embedded with {var} commands are {{cmd}}.</p><p>The variables in the template are firstName, fullName, email, oldKeyId,
newKeyId, pubKeyUrl, and pubStmntUrl. The pubKeyUrl and pubStmntUrl variables
should be valid paths to files on an HTTPS protected webserver.</p><p>Once you&rsquo;ve filled out the transition statement you need to ensure both keys
are cross signed and the signatures are published.</p><pre tabindex=0><code>gpg --local-user $oldKeyId --sign-key $newKeyId
gpg --local-user $newKeyId --sign-key $oldKeyId
gpg --send-keys $oldKeyId $newKeyId
</code></pre><p>The file itself still needs to be signed by both keys which can be done with
the following command:</p><pre tabindex=0><code>gpg --local-user $oldKeyId --local-user $newKeyId --clearsign $keyTransitionFile
</code></pre><p>If both keys don&rsquo;t exist on the same machine you&rsquo;ll need to refer to the
section titled &lsquo;Multiple Clearsigned Signatures&rsquo; for how to handle the
situation.</p><p>I recommend you publish the key transition with a name that includes the date,
like <code>key-transition-2017-08-17.txt</code>.</p><h2 id=expiration--renewal-of-subkeys>Expiration / Renewal of Subkeys</h2><p>TODO: I need to cover certificate key transitions and signed key transition
statements.</p><h3 id=option-1-generate-a-new-signing--encryption-key>Option 1: Generate a new signing / encryption key</h3><p>Pros:</p><ul><li>Most secure</li><li>Some level of forward secrecy (over large time scales)</li><li>Helps protect against unknown key compromises</li></ul><p>Cons:</p><ul><li>Only one keypair stored per smartcard (decrypting old files means restoring a
backup of the old key)</li><li>More complicated</li><li>Requires users to refresh their keys about you</li></ul><p>Steps:</p><ol><li>Generate new keys</li><li>Generate CRLs for old keys</li><li>Load keys on to smartcard</li><li>Push new keys and CRLs to keyservers</li></ol><h3 id=option-2-extend-expiration>Option 2: Extend Expiration</h3><p>Pros:</p><ul><li>Simple</li><li>Fast</li></ul><pre tabindex=0><code>gpg --edit-key 0x12345678
gpg&gt; key 1
gpg&gt; expire
...
gpg&gt; key 1
gpg&gt; key 2
gpg&gt; expire
...
gpg&gt; save

gpg --send-keys 0x12345678
</code></pre><h2 id=maintenance>Maintenance</h2><p>To ensure we get updated keys and revocation announcements the keys in your
keyring should be periodically refreshed with the public key server. This can
be done all at once using the following command:</p><pre tabindex=0><code>gpg2 --refresh-keys
</code></pre><p>Likewise after modifying your own key it should be pushed to the public key
servers for consumption and availability of others.</p><pre tabindex=0><code>PRIMARY_KEY_EMAIL=sstelfox@bedroomprogrammers.net
gpg2 --send-key $(gpg2 -k $PRIMARY_EMAIL | grep pub | awk &#39;{ print $2 }&#39; | cut -d &#39;/&#39; -f 2)
</code></pre><p>There is a social network disclosure that occurs when all keys are refreshed at
once. The description of this disclosure is:</p><blockquote><p>We assume there probably exists at least one subset of public keys in this
keyring that identifies it, i.e. no other individual&rsquo;s keyring contain the
same subset of public keys.</p></blockquote><p>A personal thought potentially making this attack easier, it is very likely
that one of the keys being refreshed is owner of the keyring itself.</p><p>Trusted SSL communications (hkps) eliminates this threat for passive snoopers,
the analysis could still be done on the keyserver itself.</p><p>To avoid this individual keys would have to be refreshed independently over
time. The requests could still be tied to the keyring machine&rsquo;s IP address to
correlate all the refreshed keys to build back up the contents of the keyring.
Avoiding this would require use of individual Tor circuits to mask and
distribute key refreshes.</p><p>A project has been built up to handle this issue. The following are relevant:</p><ul><li><a href="https://code.openhub.net/file?fid=BbMaEKchr9cDAOVs8ozX5mJ40g8&amp;cid=RfbvTf3fwdw&amp;fp=405976&amp;mp&amp;projSelected=true#L0">https://code.openhub.net/file?fid=BbMaEKchr9cDAOVs8ozX5mJ40g8&amp;cid=RfbvTf3fwdw&amp;fp=405976&amp;mp&amp;projSelected=true#L0</a></li><li><a href=https://github.com/EtiennePerot/parcimonie.sh/blob/master/parcimonie.sh>https://github.com/EtiennePerot/parcimonie.sh/blob/master/parcimonie.sh</a></li></ul><h2 id=diagnostics>Diagnostics</h2><h3 id=no-usuable-subkey>No Usuable Subkey</h3><p>One one of my devices I was persistently getting an odd error message whenever
I tried to sign something. The error message was:</p><pre tabindex=0><code>$ gpg2 -esar sam@stelfox.net sample-file
gpg: no default secret key: Unusable secret key
gpg: tor-setup-script.sh: sign+encrypt failed: Unusable secret key
</code></pre><p>Turns out I hadn&rsquo;t updated my public keys on that device and <code>gpg2 --card-edit</code>
followed by a <code>fetch</code> didn&rsquo;t actually update my certificate. I needed to
refresh the key from the key server to get my new signatures and public key and
retrust it.</p><pre tabindex=0><code>gpg2 --refresh-keys 0x30856D4EA0FFBA8F
gpg2 --edit-key 0x30856D4EA0FFBA8F
trust
</code></pre><h3 id=card-not-visible-to-user-may-be-seen-by-root>Card Not Visible to User (May be seen by root)</h3><p>I installed <code>pcsc-tools</code> to get <code>pcsc_scan</code> but I don&rsquo;t believe that
contributed to the fix. Ultimately I needed to start up the <code>pcscd</code> service and
replug my yubikey.</p><h3 id=unable-to-connect-to-dirmngr-ipc-connect-call-failed>Unable to connect to dirmngr (IPC connect call failed)</h3><p>While trying to refresh keys I was getting the following error:</p><pre tabindex=0><code>gpg: connecting dirmngr at &#39;/run/user/1000/gnupg/S.dirmngr&#39; failed: IPC connect call failed
</code></pre><p>I rebooted the machine, and that didn&rsquo;t solve it. Ultimately I believe it was
permissions / ownership issues on the <code>~/.gnupg/crls.d</code> directory but I can&rsquo;t
be entirely sure.</p><p>I solved this issue by deleting everything in my <code>.gnupg</code> directory and
checking out the version from my dotfiles again.</p><h2 id=remote-usage-of-smartcard>Remote Usage of Smartcard</h2><p>Basically relies on the extra-socket option for gpg-agent. May be able to
accomplish this with something like the following command (path may be
incorrect):</p><pre tabindex=0><code>ssh -R /run/user/1000/gnupg/S.gpg-agent:/home/sstelfox/.gnupg/S.gpg-agent.remote  -o &#34;StreamLocalBindUnlink=yes&#34; remote-host
</code></pre><p>This could also live in an <code>ssh/config</code> parameter like so:</p><pre tabindex=0><code>Host remote
  RemoteForward /run/user/1000/gnupg/S.gpg-agent:/home/sstelfox/.gnupg/S.gpg-agent.remote
  StreamLocalBindUnlink yes
</code></pre><p>The following command should work but will warn about the agent being in
restricted mode.</p><pre tabindex=0><code>gpg-connect-agent /bye
</code></pre><h2 id=multiple-clearsigned-signatures>Multiple Clearsigned Signatures</h2><p>If multiple keys on different machines need to perform a clearsign on a
document the normal method doesn&rsquo;t support combining these signatures to be
verified in one pass. This is valuable for allowing multiple independent people
to attest to the validity of a document and make it easy for people to validate
the correctness of it.</p><h3 id=notes>Notes</h3><p>If the private keys are on the same machine the <code>--local-user</code> flag can simply
be specified multiple times. This is likely the most applicable for
key-transition statements.</p><pre tabindex=0><code>gpg2 --local-user pers1 --local-user pers2 --clearsign content
</code></pre><p>ONLY PARTIALLY IDEAL: Detached signatures can be combined in the same way and
don&rsquo;t require a lot of the sed magic used here. A detached signature can be
generated with:</p><pre tabindex=0><code>gpg2 --armor --detach-sign content
</code></pre><p>If this is done only the dearmor, split, combine, enarmor steps need to be
performed.</p><h3 id=process>Process</h3><p>First we need content to sign:</p><pre tabindex=0><code>echo &#39;A very important statement about a very important topic.&#39; &gt; content
</code></pre><p>Each signatory should receive or generate a copy of the content and verify it.
This transport is beyond the scope of this document but could easily be done
with a standard <code>gpg2 -esa -r pers1 -r pers2 content</code> and emailed then
decrypted.</p><p>Once each user has a copy and verified it. They need to perform a normal
clearsign on the content and send the signed message back to an individual to
perform the combinatory process.</p><pre tabindex=0><code>gpg2 --clearsign content
</code></pre><p>This assumes you now have the signed contents file from pers1 and pers2 in the
files <code>content.pers1.asc</code> and <code>content.pers2.asc</code>. Verify both signatures are
valid:</p><pre tabindex=0><code>gpg2 --verify content.pers1.asc
gpg2 --verify content.pers2.asc
</code></pre><p>We need to verify the content is still identical in both files (one of them
could have changed the content before signing to be tricky). This is kind of a
formality since the signature won&rsquo;t check out for at least one of them if the
content differs between the two in any way.</p><pre tabindex=0><code>sed -n &#39;1,/SIGNATURE/ p&#39; content.pers1.asc | sha1sum
sed -n &#39;1,/SIGNATURE/ p&#39; content.pers2.asc | sha1sum
</code></pre><p>We then need to extract just the signature blocks from each message and turn
them into the raw gpg2 packets:</p><pre tabindex=0><code>sed -n &#39;/SIGNATURE/,$ p&#39; content.pers1.asc | gpg2 --dearmor | gpgsplit --no-split &gt; pers1.sig
sed -n &#39;/SIGNATURE/,$ p&#39; content.pers2.asc | gpg2 --dearmor | gpgsplit --no-split &gt; pers2.sig
</code></pre><p>We then combine them into one enarmored signature (order doesn&rsquo;t matter):</p><pre tabindex=0><code>cat pers1.sig pers2.sig | gpg2 --enarmor | sed -n &#39;5,$ p&#39; | grep -v -- ----- &gt; combo.sig
</code></pre><p>And append the signatures back onto the content:</p><pre tabindex=0><code>(sed -n &#39;1,/SIGNATURE/ p&#39; content.pers1.asc; echo; cat combo.sig; \
  echo &#39;-----END PGP SIGNATURE-----&#39;) &gt; content.combo.asc
</code></pre><p>Verify the signatures are still good:</p><pre tabindex=0><code>gpg2 --verify content.combo.asc
</code></pre></div></article><hr><div class=post-info><p><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-tag meta-icon"><path d="M20.59 13.41l-7.17 7.17a2 2 0 01-2.83.0L2 12V2h10l8.59 8.59a2 2 0 010 2.82z"/><line x1="7" y1="7" x2="7" y2="7"/></svg>
<span class=tag><a href=https://stelfox.net/tags/gpg/>gpg</a></span>
<span class=tag><a href=https://stelfox.net/tags/linux/>linux</a></span>
<span class=tag><a href=https://stelfox.net/tags/security/>security</a></span></p></div></main></div><footer class=footer></footer></div><script type=text/javascript src=/bundle.min.85fad2de4f13fec3bcb3b3cb10430cdb44a7b4a9749b32938241a5c6e77718df7624f1002b880521fdc26e24ec1077fda214bf1cb36ee3045510760d09638cae.js integrity="sha512-hfrS3k8T/sO8s7PLEEMM20SntKl0mzKTgkGlxud3GN92JPEAK4gFIf3CbiTsEHf9ohS/HLNu4wRVEHYNCWOMrg=="></script></body></html>